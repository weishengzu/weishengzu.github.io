<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>正则表达式语法</title>
    <link href="/2022/12/01/%E5%B7%A5%E5%85%B7-2022-12-08-%E6%AD%A3%E5%88%99%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/12/01/%E5%B7%A5%E5%85%B7-2022-12-08-%E6%AD%A3%E5%88%99%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一名程序员，我一直对文本的处理感到困惑。如果要对文本进行某种操作，例如查找符合某个规则的文本，替换某些字符，检查格式等，则需要耗费大量时间和精力。然而，当我第一次接触到正则表达式时，我意识到这一切都可以改变，正则表达式就是为处理这些复杂的文本问题而发明的，但正则表达式语法晦涩难懂如果长时间不使用容易遗忘。因此，我决定写一篇关于正则表达式常用语法的博客，以帮助其他人更好地理解和使用正则表达式，同时也方便自己查阅。</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>正则表达式（Regular Expression）是一种特殊的字符串模式，可以用于验证、搜索和替换文本数据。它是由一系列字符和元字符组成，这些字符和元字符描述了要查找的字符串的模式。作为计算机领域最伟大的发明之一，正则表达式简单、强大，它可以极大的提高我们工作中对文本的处理效率。</p><h1 id="基本字符"><a href="#基本字符" class="headerlink" title="基本字符"></a>基本字符</h1><p>正则表达式中的基本字符是普通字符，如字母、数字和符号。这些字符表示为本身，例如字母“a”表示为“a”。当正则表达式中搜索基本字符时，只有与文本数据中的字符完全匹配的字符才会被视为匹配。</p><p>例如，如果使用正则表达式“a”搜索字符串“apple”，则仅在文本数据中的字符“a”处匹配。</p><h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><p><strong>所谓元字符就是指那些在正则表达式中具有特殊意义的字符</strong>，元字符是构成正则表达式的基本元件，正则就是一系列的元字符组成的。元字符大致可分成这几类：表示单个字符的，表示空白字符的，表示某个范围的，表示次数的量词，表示边界限定的断言。</p><h2 id="1-特殊字符"><a href="#1-特殊字符" class="headerlink" title="1.特殊字符"></a>1.特殊字符</h2><p>正则表达式中的反斜杠字符 () 指示其后跟的字符就是特殊字符，常用的特殊单字符如下：</p><ul><li><code>.</code>  匹配换行以外的任意单个字符</li><li><code>\d</code> 匹配任意的单个数字</li><li><code>\w</code> 匹配任意的单个字母数字或下划线</li><li><code>\s</code> 匹配任意的单个空白符</li><li><code>\D</code> 匹配任意的非单个数字</li><li><code>\W</code> 匹配任意的非单个字母数字或下划线</li><li><code>\S</code> 匹配任意的非单个空白符</li></ul><p>以下是一个匹配字母数字或下划线文本的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::string input = <span class="hljs-string">&quot;abc_123&quot;</span>;<br>  <span class="hljs-function">std::regex <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">R&quot;(\w+)&quot;</span>)</span></span>;<br><br>  <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(input, pattern)) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Match not found.&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-comment">//输出：Match found!</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-空白字符"><a href="#2-空白字符" class="headerlink" title="2.空白字符"></a>2.空白字符</h2><p>除了特殊单字符外，处理文本时经常还会遇到空格、换行等空白符。正则中的空白符如下所示：</p><ul><li><code>\s</code> 匹配任何空白字符，包括空格、制表符、换行符等</li><li><code>\t</code> 匹配制表符</li><li><code>\r</code> 匹配回车符</li><li><code>\n</code> 匹配换行符</li><li><code>\f</code> 匹配换页符</li><li><code>\v</code> 匹配垂直制表符<br>平常使用正则，大部分场景使用\s就可以满足需求，代表任意单个空白符。</li></ul><p>以下是一个使用这些空白字符的示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::string input = <span class="hljs-string">&quot;  abc\t123\n456\r789&quot;</span>;<br>  <span class="hljs-function">std::regex <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">R&quot;(\s+)&quot;</span>)</span></span>;<br><br>  std::cout &lt;&lt; std::<span class="hljs-built_in">regex_replace</span>(input, pattern, <span class="hljs-string">&quot; &quot;</span>) &lt;&lt; std::endl; <span class="hljs-comment">//输出：abc 123 456 789</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-量词"><a href="#3-量词" class="headerlink" title="3.量词"></a>3.量词</h2><p>量词(也称限定符)是正则表达式中的特殊字符，用于指定字符出现的次数。例如，如果你想匹配字符串中的三个连续数字，则可以使用“\d{3}”的正则表达式。</p><p>限定符的常见类型包括：</p><ul><li>?：表示字符可以出现0次或1次</li><li>*：表示字符可以出现0次或多次</li><li>+：表示字符必须出现1次或多次</li><li>{n}：表示字符必须出现n次</li><li>{n,}：表示字符必须出现至少n次</li><li>{n,m}：表示字符必须出现从n到m次</li></ul><p>以限定符”?”为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::string input1 = <span class="hljs-string">&quot;colour&quot;</span>;<br>  std::string input2 = <span class="hljs-string">&quot;color&quot;</span>;<br>  std::string input3 = <span class="hljs-string">&quot;colo&quot;</span>;<br>  <span class="hljs-function">std::regex <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;colou?r&quot;</span>)</span></span>;  <span class="hljs-comment">// 匹配字符串&quot;colour&quot;或&quot;color&quot;</span><br>  std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="hljs-built_in">regex_match</span>(input1, pattern) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出true</span><br>  std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="hljs-built_in">regex_match</span>(input2, pattern) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出true</span><br>  std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="hljs-built_in">regex_match</span>(input3, pattern) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出false</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-范围"><a href="#4-范围" class="headerlink" title="4.范围"></a>4.范围</h2><p>在正则表达式中，我们可以使用特殊的符号来表示一个字符的可能出现的范围。这样，我们可以快速地匹配更多的字符，而不是一个一个字符地匹配。常用的表示范围的符号有：</p><ul><li>|：或，表示满足其中任意一个就行，如 ab|bc 表示匹配ab或者bc</li><li>[ ]：字符集合，表示中括号中的字符可以任意出现</li><li>[^ ]：非字符集合，表示不能出现中括号中的字符</li><li>-：范围，表示一个字符的可能范围，如[a-z]表示任意小写字母</li></ul><p>匹配字符串以 http:&#x2F;&#x2F;、https:&#x2F;&#x2F; 或 ftp:&#x2F;&#x2F; 开头的正则示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string url = <span class="hljs-string">&quot;http://www.example.com&quot;</span>;<br>  <span class="hljs-function">std::regex <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;(https?://|ftp://).*&quot;</span>)</span></span>;<br><br>  <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(url, pattern)) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The URL matches the pattern.&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The URL does not match the pattern.&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-comment">//输出：The URL matches the pattern.</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-断言"><a href="#5-断言" class="headerlink" title="5.断言"></a>5.断言</h2><p>在有些情况下，我们对要匹配的文本位置有一定的要求，为了解决这个问题，正则中提供了一些结构，只用于匹配位置，而不是文本内容的本身，这种结构就是断言。常见的断言为字符边界与零宽端言。</p><h3 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h3><p>字符边界分类如下：</p><ul><li><code>\b</code> 匹配单词边界</li><li><code>\B</code> 匹配非单词边界</li><li><code>^</code>  匹配字符串的开头</li><li><code>$</code>  匹配字符串的结尾</li></ul><p>\b 用来匹配一个单词边界，它通常与某个单词进行匹配，例如：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-string">&quot;<span class="hljs-char escape_">\b</span>word<span class="hljs-char escape_">\b</span>&quot;</span>匹配<span class="hljs-string">&quot;word&quot;</span>，但不匹配<span class="hljs-string">&quot;words&quot;</span><br></code></pre></td></tr></table></figure><p>^ 在[]外表示匹配开头的意思，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">^abc <span class="hljs-regexp">//</span> 可以匹配abc，但是不能匹配aabc<br></code></pre></td></tr></table></figure><p>$ 表示匹配结尾的意思，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">abc$ <span class="hljs-regexp">//</span> 可以匹配 abc ，但是不能匹配 abcc<br></code></pre></td></tr></table></figure><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>零宽断言简单来说就是要求匹配的部分前面或后面要满足某种规则，分类如下：</p><ul><li>(?&lt;&#x3D;Y)X 匹配前面是Y的X</li><li>(?&lt;!Y)X 匹配前面不是Y的X</li><li>X(?&#x3D;Y) 匹配后面是Y的X</li><li>X(?&#x3D;!Y) 匹配后面不是Y的X</li></ul><p>假如你要匹配以“ing”结尾的单词，可以有如下两种写法：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">\b\w+(?=ing\b)<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">(?&lt;=\b\w+)ing\b<br></code></pre></td></tr></table></figure><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>分组是正则中非常强大的一个功能，可以让上面提到的量词作用于一组字符，而非单个字符，分组的语法是圆括号包裹(xxx)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">(abc)&#123;<span class="hljs-number">2</span>&#125; <span class="hljs-regexp">//</span> 匹配abcabc<br></code></pre></td></tr></table></figure><p>分组不能放在[]中，分组中还可以使用选择表达式</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">(<span class="hljs-number">123</span>|<span class="hljs-number">456</span>)&#123;<span class="hljs-number">2</span>&#125; <span class="hljs-regexp">//</span> 匹配 <span class="hljs-number">123123</span>、<span class="hljs-number">456456</span>、<span class="hljs-number">123456</span>、<span class="hljs-number">456123</span><br></code></pre></td></tr></table></figure><h1 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h1><p>正则表达式中还有两个重要的概念：贪婪和非贪婪(懒惰)。这两个概念影响正则表达式如何匹配字符串。</p><ul><li><strong>贪婪匹配</strong>：指正则表达式尽可能多地匹配字符串，它将尽可能多地匹配字符串中的字符，直到匹配下一个字符为止</li><li><strong>非贪婪(懒惰)匹配</strong>：表示正则表达式应尽可能少地匹配字符串，它将尽可能少地匹配字符串中的字符，直到匹配下一个字符为止</li></ul><p>在正则表达式中，表示次数的量词默认是贪婪的，在贪婪模式下，会尝试尽可能最大长度去匹配，例如：<br><img src="/image/doc/%E6%AD%A3%E5%88%99%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D.png" alt="贪婪匹配示例"></p><p>那么如何切换到非贪婪匹配模式呢？仅需在量词的后面加上英文的问号(?)即可，例如：<br><img src="/image/doc/%E6%AD%A3%E5%88%99%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D.png" alt="非贪婪匹配示例"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>正则表达式由于语法复杂不太直观，很难判定你写的正则表达式是否就一定正确，要善于利用网络与工具才能又快又准，如：</p><ul><li>正则表达式在线生成工具<a href="https://regex101.com/">Regex101</a>，可以帮助生成正则表达式，同时也可以测试正则表达式的效果，便于调整</li><li><a href="https://github.com/cdoco/common-regex">https://github.com/cdoco/common-regex</a> 查看常用正则表达式</li></ul><p>正则中最容易忘记的就是各种元字符，看不懂元字符的含义便如同看天书，最后总结一下元字符的分类如下：<br><img src="/image/doc/%E6%AD%A3%E5%88%99%E5%85%83%E5%AD%97%E7%AC%A6.png" alt="正则元字符"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://yanhaijing.com/javascript/2017/08/06/regexp-syntax/">https://yanhaijing.com/javascript/2017/08/06/regexp-syntax/</a></li><li><a href="https://deerchao.cn/tutorials/regex/regex.htm">https://deerchao.cn/tutorials/regex/regex.htm</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows程序crash定位方法</title>
    <link href="/2022/10/28/%E5%85%B6%E4%BB%96-2022-10-28-Windows%E7%A8%8B%E5%BA%8Fcrash%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2022/10/28/%E5%85%B6%E4%BB%96-2022-10-28-Windows%E7%A8%8B%E5%BA%8Fcrash%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于客户环境复杂多样, 发布的软件，经常会出现在本地测试无法重现的问题，当发生这种情况时，我们怎么去排查，怎么去分析原因呢？<br>作为 Windows 软件开发人员，我们都广泛使用 Visual Studio 或 WinDbg 来进入我们的代码、设置断点、观察变量以及执行许多其他与应用程序调试相关的有用任务，我们知道存在一种内部机制，以便调试器能够将源代码映射到二进制文件并进入许多可用的运行时库。如果用户的应用程序崩溃时，我们能够获取到必要的崩溃信息做为输入，模拟在本地开启调试模式时的应用程序crash，直接定位到程序崩溃调用堆栈并定位到具体的实现文件与代码行号，这样排查crash问题是不是要容易的多？<br>程序崩溃时直接定位到源代码位置需要三个充要条件：</p><ul><li><strong>一份应用程序发布时完全一致的源代码</strong></li><li><strong>应用程序Crash时生成的dump文件</strong></li><li><strong>应用程序编译产生的PDB(Program Databasse)文件</strong></li></ul><h3 id="关于Dump文件"><a href="#关于Dump文件" class="headerlink" title="关于Dump文件"></a>关于Dump文件</h3><p>dump文件是一个进程或者系统在某一个给定的时间的快照，<strong>文件中包含了程序运行的模块信息、线程信息、堆栈调用信息、异常信息等数据</strong>。这个文件由发生程序崩溃问题的用户机器上获取，至于这个文件如何产生以及收集不在本文讨论范围。</p><h3 id="关于PDB文件"><a href="#关于PDB文件" class="headerlink" title="关于PDB文件"></a>关于PDB文件</h3><p>PDB文件主要会存储对应模块(dll或者exe)内部的所有符号，以及符号对应的地址、文件名和行号，正是归功于这个文件，我们才能在debug的时候看到程序当前执行相对应的代码和监视到一些变量。C++ PDB 文件包含了以下信息：</p><ul><li>公有函数，私有函数和静态函数的地址</li><li>全局变量的名称和地址</li><li>参数和局部变量的名称以及栈上的偏移量</li><li>类，结构体以及数据定义的类型信息</li><li>FPO（Frame Pointer Omission） 数据</li><li>源文件的文件名及行信息。</li></ul><h4 id="PDB文件什么时候产生"><a href="#PDB文件什么时候产生" class="headerlink" title="PDB文件什么时候产生"></a>PDB文件什么时候产生</h4><p>PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的。我们一般可能不会意识到PDB文件的重要性，因为如果只是我们本地进行开发，我们总是能够进行调试。这里首先定义两个概念：</p><ul><li>**Private Build(本地编译)**：在你本机开发环境中的编译。</li><li>**Public Build(官方编译)**：在编译服务器上的编译。</li></ul><p>这两种编译的区分很重要，调试本地编译往往很简单，因为在编译出来的机器上进行调试所有必要的文件都在该在的地方，但是问题往往出现在官方编译中。官方编译至少需要有一个地方（Symbol Server）来存放编译出来的二进制及 PDB 文件。这样当某个版本发现任何问题，我们可以获取到对应的 PDB 文件进行调试。没有匹配的 PDB 文件，调试器几乎不可能完成调试任务，或者你将付出高昂的代价才能解决问题。<br>如果你的应用程序需要发布或者当作产品卖得，你就需要特别注意要保存你发布出去的那个版本的PDB文件和源文件。<strong>注意：你只有一次机会保存着发布出去的PDB文件，如果你弄丢了将无法找回（原因下面说明）</strong></p><h4 id="Cmake项目如何生成PDB"><a href="#Cmake项目如何生成PDB" class="headerlink" title="Cmake项目如何生成PDB"></a>Cmake项目如何生成PDB</h4><p>当Cmake项目的CMAKE_BUILD_TYPE为Debug时Windows环境下编译默认会生成PDB文件，Release则默认不生成PDB文件。有时希望编译Release版本时同样生成PDB文件又该如何做呢？可以使用以下两种方法：<br>1.设置CMAKE_BUILD_TYPE&#x3D;RelWithDebInfo<br>2.在CMakeLists.txt中打开生成PDB的开关，一般可以无脑设置如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#symbol file for debug</span><br><span class="hljs-keyword">if</span> (CMAKE_BUILD_TYPE MATCHES Release)<br>    <span class="hljs-built_in">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; /Zi&quot;</span>) #编译器生成调试信息<br>    <span class="hljs-built_in">set</span>(CMAKE_SHARED_LINKER_FLAGS_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS_RELEASE&#125; /DEBUG /OPT:REF /OPT:ICF&quot;</span>) #链接器生成dll时加入调试信息<br>    <span class="hljs-built_in">set</span>(CMAKE_EXE_LINKER_FLAGS_RELEASE <span class="hljs-string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS_RELEASE&#125; /DEBUG /OPT:REF /OPT:ICF&quot;</span>) #链接器生成exe时加入调试信息<br><span class="hljs-built_in">endif</span>()<br></code></pre></td></tr></table></figure><h4 id="为什么只有一次机会保存着发布出去的PDB文件"><a href="#为什么只有一次机会保存着发布出去的PDB文件" class="headerlink" title="为什么只有一次机会保存着发布出去的PDB文件"></a>为什么只有一次机会保存着发布出去的PDB文件</h4><p>也许你会认为如果拿一份一模一样的源代码重新编译生成一个PDB文件，然后用来调试就行了。我也曾经这么认为过，直到有一天………<br>直接的原因是因为VS生成出来的二进制文件的Header部分里面包含了它对应的PDB的GUID，PDB也包含一个GUIID，这两个GUID是在编译的时候添加进去的。VS调试器在载入PDB的时候会去比对这个两个GUID，如果不一致，那么就不能使用。当然上面那个原因只是一个表面现象，根本原因是即使两份一模一样的代码编译器编译出来的文件可能是不一样的。因为编译器在编译的时候会对代码进行优化，而同一份代码可能会有很多种优化的方法，它会根据当时的具体机器的环境等情况选择一个最快的生成方法。所以它生成出来的文件有可能是不一样的！所以如果连生成出来的文件都不一样，那么原来的那个PDB里面的符号对应的地址也就没有意义了。<br>所以，<strong>发布版本时一定要保留一份打包机器编译产生的PDB文件，同时在git上打好对应的Tag以便定位对应版本的源代码。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>windows</tag>
      
      <tag>pdb</tag>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令清单</title>
    <link href="/2022/10/05/Git-2022-10-05-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
    <url>/2022/10/05/Git-2022-10-05-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><ul><li>HEAD 为最近一个提交，即当前版本 </li><li>HEAD^ 或 HEAD~ 为上一次提交</li></ul><h3 id="创建存储库"><a href="#创建存储库" class="headerlink" title="创建存储库"></a>创建存储库</h3><p>创建一个新的本地存储库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [项目名称]</span><br></code></pre></td></tr></table></figure><p>克隆存储库(代码仓库)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> &lt;git_url&gt;</span><br></code></pre></td></tr></table></figure><p>将存储库克隆到指定目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> &lt;git_url&gt; 指定目录</span><br></code></pre></td></tr></table></figure><p>将存储库克隆到指定目录，并指定分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> &lt;git_url&gt; -b &lt;分支名称&gt; 指定目录</span><br></code></pre></td></tr></table></figure><h3 id="代码变更"><a href="#代码变更" class="headerlink" title="代码变更"></a>代码变更</h3><p>在工作目录中<strong>显示</strong>修改后的文件，为您的下一次提交暂存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br></code></pre></td></tr></table></figure><p>将文件写入暂存区，准备提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [file]</span><br></code></pre></td></tr></table></figure><p>将<strong>所有</strong>更改的文件写入暂存区，准备提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br></code></pre></td></tr></table></figure><p>将暂存区内容添加到本地仓库中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;commit message&quot;</span></span><br></code></pre></td></tr></table></figure><p>重写最后的提交信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -v --amend</span><br></code></pre></td></tr></table></figure><p>取消暂存文件，保留文件更改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git reset [file]</span><br></code></pre></td></tr></table></figure><p>将所有内容恢复到最后一次提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git reset --hard</span><br></code></pre></td></tr></table></figure><p>将所有内容恢复到上一次提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD~</span><br></code></pre></td></tr></table></figure><p>将所有内容恢复到 git add 加入暂存区之前</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git reset --mixed</span><br></code></pre></td></tr></table></figure><p>将所有内容恢复到 git commit 提交修改信息之前</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git reset --soft</span><br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>查看全局配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global -l</span><br></code></pre></td></tr></table></figure><p>设置将附加到您的提交和标签的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="hljs-string">&quot;name&quot;</span></span><br></code></pre></td></tr></table></figure><p>设置将附加到您的提交和标签 tags 的<strong>电子邮件地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="hljs-string">&quot;email&quot;</span></span><br></code></pre></td></tr></table></figure><p>设置忽略ssl证书验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global http.sslVerify <span class="hljs-literal">false</span></span><br></code></pre></td></tr></table></figure><h3 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h3><p>列出所有本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch</span><br></code></pre></td></tr></table></figure><p>列出所有分支，本地和远程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -av</span><br></code></pre></td></tr></table></figure><p>切换到 <code>my_branch</code>，并更新工作目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout my_branch</span><br></code></pre></td></tr></table></figure><p>从远程分支中创建并切换到本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></code></pre></td></tr></table></figure><p>删除名为 <code>my_branch</code> 的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d my_branch</span><br></code></pre></td></tr></table></figure><p>删除当前本地分支外的所有分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch | xargs git branch -d</span><br></code></pre></td></tr></table></figure><p>将分支 <code>A</code> 合并到分支 <code>B</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout branchB</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge branchA</span><br></code></pre></td></tr></table></figure><h3 id="临时提交"><a href="#临时提交" class="headerlink" title="临时提交"></a>临时提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">保存已修改和分阶段的更改</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git stash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出隐藏文件更改的堆栈顺序</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git stash list</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从存储堆栈顶部编写工作</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git stash pop</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">丢弃存储堆栈顶部的更改</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git stash drop</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">回到某个 stash 的状态</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git stash apply &lt;stash@&#123;n&#125;&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有的 stash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git stash clear</span><br></code></pre></td></tr></table></figure><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><!--rehype:wrap-class=row-span-2--><p>从该 Git 远程获取所有分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch [<span class="hljs-built_in">alias</span>]</span><br></code></pre></td></tr></table></figure><p>将本地分支提交传输到远程存储库分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push [<span class="hljs-built_in">alias</span>] [branch]</span><br></code></pre></td></tr></table></figure><p>从跟踪远程分支获取并合并任何提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br></code></pre></td></tr></table></figure><p>将另一个分支的一个特定提交合并到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cherry-pick [commit_id]</span><br></code></pre></td></tr></table></figure><p>查看远程分支和本地分支的对应关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote show origin<br></code></pre></td></tr></table></figure><p>同步本地分支与远程分支的对应关系(将删除本地存在但远程已删除的分支)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote prune origin</span><br></code></pre></td></tr></table></figure><h3 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h3><ul><li><p><strong>重命名</strong>为<code>new</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -m &lt;new&gt;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -m &lt;old&gt; &lt;new&gt; <span class="hljs-comment">#重命名分支</span></span>  <br></code></pre></td></tr></table></figure></li><li><p><strong>推送</strong>并重置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin -u &lt;new&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>删除</strong>远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;old&gt; <span class="hljs-comment">#方法1</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin :oldBranchName <span class="hljs-comment">#方法2</span></span><br></code></pre></td></tr></table></figure></li></ul><h3 id="中文乱码的解决方案"><a href="#中文乱码的解决方案" class="headerlink" title="中文乱码的解决方案"></a>中文乱码的解决方案</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global core.quotepath <span class="hljs-literal">false</span></span><br></code></pre></td></tr></table></figure><h3 id="Commit-提交信息规范"><a href="#Commit-提交信息规范" class="headerlink" title="Commit 提交信息规范"></a>Commit 提交信息规范</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>build:</code></td><td>变更影响的是<strong>构建系统</strong>或者<strong>外部依赖</strong> (如: cmake, npm)</td></tr><tr><td><code>ci:</code></td><td>修改了 CI 配置文件或脚本</td></tr><tr><td><code>chore:</code></td><td>变更不影响源代码或测试（如更新了辅助工具、库等)</td></tr><tr><td><code>docs:</code></td><td>只修改了文档</td></tr><tr><td><code>feat:</code></td><td>一个新特性</td></tr><tr><td><code>fix:</code></td><td>修复了一个 Bug</td></tr><tr><td><code>perf:</code></td><td>增强性能的代码变更</td></tr><tr><td><code>refactor:</code></td><td>并非修复 Bug 或添加新特性的代码变更</td></tr><tr><td><code>revert:</code></td><td>回退代码</td></tr><tr><td><code>style:</code></td><td>变更不影响一些有意义的代码 (如: 删除空格、格式化代码、添加分号等)</td></tr><tr><td><code>test:</code></td><td>添加测试代码或修正已有的测试</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 日志框架 spdlog初步上手</title>
    <link href="/2022/09/23/C-2022-09-23-spdlog%E5%88%9D%E6%AD%A5%E4%B8%8A%E6%89%8B/"/>
    <url>/2022/09/23/C-2022-09-23-spdlog%E5%88%9D%E6%AD%A5%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>近期开发项目的过程中遇到一个需求，<strong>需要以特定的格式规范打印程序的运行日志</strong>，具体的格式可能如下：</p><table><thead><tr><th>timestamp</th><th>PID</th><th>TID</th><th>sys</th><th>log-level</th><th>log-msg</th></tr></thead><tbody><tr><td>时间戳</td><td>进程id</td><td>线程id</td><td>运行环境</td><td>日志级别</td><td>日志内容</td></tr></tbody></table><p>这么做的目的是为了能够统一公司各项目日志输出格式，这样项目引用其他小伙伴开发的库时，大家都以能相同的格式输出日志信息，方便大家调试与查bug，毕竟如果大家都按自己的方式来打印日志信息，那么日志看起来会非常没有规则，那真是谁看谁闹心。经调研发现spdlog是目前最受欢迎的c++日志库，功能也完全满足我的需求，果断集成！</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>spdlog 是一个快速的 C++ 日志库，兼容 C++11，只包含头文件，是一个head-only库，这点很实用，不用处理c++麻烦的库依赖问题，集成简单，详细的使用方法推荐查看<a href="https://github.com/gabime/spdlog/wiki">官方文档</a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>大多数能想到的日志库特性它都支持，如下：</p><ul><li>非常快</li><li>只包含头文件</li><li>无需依赖第三方库</li><li>支持跨平台 - Linux &#x2F; Windows on 32&#x2F;64 bits</li><li>支持多线程</li><li>支持异步模式(可选)</li><li>支持控制台日志输出(支持颜色)</li><li>支持日志输出级别</li><li>可自定义日志格式，功能丰富的格式，使用优秀的<a href="https://github.com/fmtlib/fmt">fmt</a>库<blockquote><p>{fmt}是一个现代 C++ 字符串格式化开源库，为 C stdio 和 C++ iostreams 提供了一种快速安全的替代方案</p></blockquote></li></ul><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="sinks-日志记录器槽"><a href="#sinks-日志记录器槽" class="headerlink" title="sinks(日志记录器槽)"></a>sinks(日志记录器槽)</h2><p>sink是实际将日志写入其目标的对象，每个sink应该只负责单个目标（例如文件、控制台、数据库）的日志写入操作，每一个sink也有自己的formatter对象设置日志的输出格式。sink具有 <strong>_mt</strong>（多线程multi threaded）或 <strong>_st</strong>（单线程single threaded）后缀来指示是否线程安全。sink也支持自定义，可查看<a href="https://spdlog.docsforge.com/v1.x/4.sinks/#available-sinks">官方资料</a>。</p><p><strong>常用的sink</strong></p><ul><li>rotating_file_sink:当文件达到最大容量时自动创建新的日志文件，也称滚动日志或循环日志</li><li>daily_file_sink:每天都创建新的日志文件，可以指定时间</li><li>simple_file_sink:简单的日志文件，没有任何限制</li><li>stdout_sink&#x2F;stderr_sink: 输出到控制台的sink</li><li>ostream_sink:写入到std::ostringstream</li><li>null_sink:不会记录日志，直接删除</li><li>syslog_sink:发送日志到syslog</li><li>systemd_sink:发送日志到systemd</li><li>dist_sink:分布式日志到所有的其他sink上</li><li>msvc_sink:windows debug sink</li><li>dup_filter_sink:移除重复的message的sink</li></ul><h2 id="logger-日志记录器"><a href="#logger-日志记录器" class="headerlink" title="logger(日志记录器)"></a>logger(日志记录器)</h2><p>被顶层调用来输出日志的类。一个logger对象中存储有多个sink，每次调用log时(如果日志级别正确)，logger会在每个sink上调用sink(log_msg) 函数进行输出。与自带的sink对应，spdlog也自带了几种logger分别对应sink，logger也区分 <strong>_mt</strong> 或 <strong>_st</strong> 版本。<br><strong>使用工厂函数创建记录器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Create and return a shared_ptr to a multithreaded console logger.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/stdout_color_sinks.h&quot;</span></span><br><span class="hljs-keyword">auto</span> console = spdlog::<span class="hljs-built_in">stdout_color_mt</span>(<span class="hljs-string">&quot;some_unique_name&quot;</span>);<br></code></pre></td></tr></table></figure><p>这将创建一个控制台记录器，在 spdlog 的全局注册表中将其注册为“some_unique_name”作为其 id，并将其作为 shared_ptr 返回，可以使用<code>spdlog::get(&quot;logger_name&quot;)</code>返回共享指针，从任何地方访问记录器。<br><strong>创建具有多个接收器的记录器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;spdlog::sink_ptr&gt; sinks;<br>sinks.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_st&gt;());<br>sinks.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::daily_file_sink_st&gt;(<span class="hljs-string">&quot;logfile&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>));<br><span class="hljs-keyword">auto</span> combined_logger = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-built_in">begin</span>(sinks), <span class="hljs-built_in">end</span>(sinks));<br><span class="hljs-comment">//register it if you need to access it globally</span><br>spdlog::<span class="hljs-built_in">register_logger</span>(combined_logger);<br></code></pre></td></tr></table></figure><p>spdlog也支持创建旋转、异步等logger，可查看<a href="https://spdlog.docsforge.com/v1.x/2.creating-loggers/">官方资料</a></p><blockquote><p>st&#x2F;mt： 对象版本，spdlog中的logger对象和sink对象都有两种版本，一种是以st结尾的单线程版本，以及以mt结尾的多线程版本<br>st：单线程版本，不用加锁，效率更高<br>多线程版本，用于多线程程序是线程安全的</p></blockquote><h1 id="自定义格式"><a href="#自定义格式" class="headerlink" title="自定义格式"></a>自定义格式</h1><p>每个记录器的接收器都有一个格式化程序，用于将消息格式化到其目的地。spdlog 的默认日志记录格式为：<br><code>[2014-10-31 23:46:59.678] [my_loggername] [info] Some message</code><br>有两种方法可以自定义记录器的格式：</p><ul><li>设置模式字符串（推荐）：<br><code>set_pattern(pattern_string);</code></li><li>或者继承spdlog::custom_flag_formatter类并实现<code>clone()</code>和<code>format(...)</code>抽象方法来自定义格式，并调用：<br><code>set_formatter(std::make_unique&lt;my_custom_formatter&gt;());</code>(<a href="https://github.com/gabime/spdlog/wiki/3.-Custom-formatting">官方示例</a>)</li></ul><h2 id="set-pattern"><a href="#set-pattern" class="headerlink" title="set_pattern(..)"></a>set_pattern(..)</h2><p>格式可以全局应用于<strong>所有注册</strong>的记录器，调用：<br><code>spdlog::set_pattern(&quot;*** [%H:%M:%S %z] [thread %t] %v ***&quot;);</code><br>    或特定的记录器对象：<br><code>some_logger-&gt;set_pattern(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</code><br>    或特定的接收器对象：<br><code>some_logger-&gt;sinks()[0]-&gt;set_pattern(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</code><br><code>some_logger-&gt;sinks()[1]-&gt;set_pattern(&quot;..&quot;);</code></p><h2 id="格式参数"><a href="#格式参数" class="headerlink" title="格式参数"></a>格式参数</h2><table><thead><tr><th><strong>flag</strong></th><th><strong>意义</strong></th><th><strong>例子</strong></th></tr></thead><tbody><tr><td>%v</td><td>要记录的实际文本</td><td>“一些用户文本”</td></tr><tr><td>%t</td><td>线程 ID</td><td>“1232”</td></tr><tr><td>%P</td><td>进程号</td><td>“3456”</td></tr><tr><td>%n</td><td>记录者的名字</td><td>“一些记录器名称”</td></tr><tr><td>%l</td><td>消息的日志级别</td><td>“debug”、“info”等</td></tr><tr><td>%L</td><td>消息的短日志级别</td><td>“D”、“I”等</td></tr><tr><td>%a</td><td>缩写的工作日名称</td><td>“Thu”</td></tr><tr><td>%A</td><td>完整的工作日名称</td><td>“Thursday”</td></tr><tr><td>%b</td><td>缩写月份名称</td><td>“Aug”</td></tr><tr><td>%B</td><td>完整的月份名称</td><td>“August”</td></tr><tr><td>%c</td><td>日期和时间表示</td><td>“Thu Aug 23 15:35:46 2014”</td></tr><tr><td>%C</td><td>2 位数的年份</td><td>“14”</td></tr><tr><td>%Y</td><td>4 位数的年份</td><td>“2014”</td></tr><tr><td>%D或者%x</td><td>短 MM&#x2F;DD&#x2F;YY 格式日期</td><td>“08&#x2F;23&#x2F;14”</td></tr><tr><td>%m</td><td>月份 01-12</td><td>“11”</td></tr><tr><td>%d</td><td>具体日期01-31</td><td>“29”</td></tr><tr><td>%H</td><td>24 小时格式 00-23</td><td>“23”</td></tr><tr><td>%I</td><td>12 小时格式 01-12</td><td>“11”</td></tr><tr><td>%M</td><td>分钟 00-59</td><td>“59”</td></tr><tr><td>%S</td><td>秒 00-59</td><td>“58”</td></tr><tr><td>%e</td><td>当前秒的毫秒部分 000-999</td><td>“678”</td></tr><tr><td>%f</td><td>当前秒的微秒部分 000000-999999</td><td>“056789”</td></tr><tr><td>%F</td><td>当前秒的纳秒部分 000000000-999999999</td><td>“256789123”</td></tr><tr><td>%p</td><td>AM&#x2F;PM</td><td>“AM”</td></tr><tr><td>%r</td><td>12 小时制</td><td>“02:55:02 pm”</td></tr><tr><td>%R</td><td>24 小时 HH:MM 时间，相当于 %H:%M</td><td>“23:55”</td></tr><tr><td>%T或者%X</td><td>ISO 8601 时间格式 (HH:MM:SS)，相当于 %H:%M:%S</td><td>“23:55:59”</td></tr><tr><td>%z</td><td>ISO 8601 时区与 UTC 的偏移量 ([+&#x2F;-]HH:MM)</td><td>“+02:00”</td></tr><tr><td>%E</td><td>自纪元以来的秒数</td><td>“1528834770”</td></tr><tr><td>%%</td><td>%号的标志</td><td>“%”</td></tr><tr><td>%+</td><td>spdlog 的默认格式</td><td>“[2014-10-31 23:46:59.678] [mylogger] [info] 一些消息”</td></tr><tr><td>%^</td><td>起始颜色范围（只能使用一次）</td><td>“[mylogger] [info(green)] 一些消息”</td></tr><tr><td>%$</td><td>结束颜色范围（例如 <code>%^[+++]%$ %v</code></td><td></td></tr><tr><td>）（只能使用一次）</td><td>[+++] 一些消息</td><td></td></tr><tr><td>%@</td><td>源文件和行（使用 SPDLOG_TRACE(..)、SPDLOG_INFO(…) 等代替 spdlog::trace(…)</td><td>my_file.c++:123</td></tr><tr><td>%s</td><td>源文件的基本名称（使用 SPDLOG_TRACE(..)、SPDLOG_INFO(…) 等）</td><td>my_file.c++</td></tr><tr><td>%g</td><td>宏中出现的源文件的完整或相对路径<strong>FILE</strong>（使用 SPDLOG_TRACE(..)、SPDLOG_INFO(…) 等）</td><td>&#x2F;some&#x2F;dir&#x2F;my_file.c++</td></tr><tr><td>%#</td><td>源代码行（使用 SPDLOG_TRACE(..)、SPDLOG_INFO(…) 等）</td><td>123</td></tr><tr><td>%!</td><td>源函数（使用 SPDLOG_TRACE(..)、SPDLOG_INFO(…) 等。</td><td>my_func</td></tr><tr><td>%o</td><td>自上一条消息以来经过的时间（以毫秒为单位）</td><td>456</td></tr><tr><td>%i</td><td>自上一条消息以来经过的时间（以微秒为单位）</td><td>456</td></tr><tr><td>%u</td><td>自上一条消息以来经过的时间（以纳秒为单位）</td><td>11456</td></tr><tr><td>%O</td><td>自上一条消息以来经过的时间（以秒为单位）</td><td>4</td></tr></tbody></table><h2 id="格式对齐"><a href="#格式对齐" class="headerlink" title="格式对齐"></a>格式对齐</h2><p>每个模式标志都可以通过预先添加一个宽度编号（最多 64 个）来对齐。<br>使用<code>-</code>(左对齐) 或<code>=</code>(居中对齐) 控制对齐边：</p><table><thead><tr><th><strong>对齐</strong></th><th><strong>意义</strong></th><th><strong>例子</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td><code>%&lt;width&gt;&lt;flag&gt;</code></td><td>右对齐</td><td><code>%8l</code></td><td>“    info”</td></tr><tr><td><code>%-&lt;width&gt;&lt;flag&gt;</code></td><td>左对齐</td><td><code>%-8l</code></td><td>“info    “</td></tr><tr><td><code>%=&lt;width&gt;&lt;flag&gt;</code></td><td>居中对齐</td><td><code>%=8l</code></td><td>“  info  “</td></tr></tbody></table><p><code>!</code>如果结果的大小超过指定的宽度，可以选择添加以截断结果：</p><table><thead><tr><th><strong>对齐</strong></th><th><strong>意义</strong></th><th><strong>例子</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td><code>%&lt;width&gt;!&lt;flag&gt;</code></td><td>右对齐或截断</td><td><code>%3!l</code></td><td>“inf”</td></tr><tr><td><code>%-&lt;width&gt;!&lt;flag&gt;</code></td><td>左对齐或截断</td><td><code>%-2!l</code></td><td>“in”</td></tr><tr><td><code>%=&lt;width&gt;!&lt;flag&gt;</code></td><td>居中对齐或截断</td><td><code>%=1!l</code></td><td>“i”</td></tr></tbody></table><blockquote><p><strong>注意：</strong> 要截断函数名称，请使用“！！”。例如%10!!将函数名称限制为 10 个字符。</p></blockquote><h1 id="日志刷新策略"><a href="#日志刷新策略" class="headerlink" title="日志刷新策略"></a>日志刷新策略</h1><p>默认情况下，spdlog会在它认为合适时刷新，输出到终端的日志应该是立即就刷新了，但输出到文件的日志会在程序正常关闭的时候才刷写到日志文件中，也就是说如果程序没有正常关闭，比如卡死或异常退出了，那么日志就会丢失。我们可以通过以下几种方式来修改刷新策略。</p><h2 id="手动刷新"><a href="#手动刷新" class="headerlink" title="手动刷新"></a>手动刷新</h2><p>使用<code>logger-&gt;flush()</code>函数立即刷新，如果要确保每条日志都立即刷新，那么就在输出一条日之后立即调用该函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">console_logger-&gt;<span class="hljs-built_in">info</span>(log);<br>console_logger-&gt;<span class="hljs-built_in">flush</span>();<br></code></pre></td></tr></table></figure><h2 id="基于严重性的刷新"><a href="#基于严重性的刷新" class="headerlink" title="基于严重性的刷新"></a>基于严重性的刷新</h2><p>可以设置触发自动刷新的最低日志级别，每当记录的日志等级高于设置的最低等级时将会自动刷新，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">my_logger-&gt;<span class="hljs-built_in">flush_on</span>(spdlog::level::err); <span class="hljs-comment">//每当记录错误或更严重的消息时，这将触发刷新</span><br></code></pre></td></tr></table></figure><h2 id="定时刷新"><a href="#定时刷新" class="headerlink" title="定时刷新"></a>定时刷新</h2><p>设置刷新间隔时间，每隔一定时间就刷新一次，例如每 5s 刷新一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">spdlog::<span class="hljs-built_in">flush_every</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><h1 id="自定义封装日志帮助类"><a href="#自定义封装日志帮助类" class="headerlink" title="自定义封装日志帮助类"></a>自定义封装日志帮助类</h1><p>有了以上的基本知识便可以封装一个满足我需求的帮助类了，这个类有以下几点基本要求：</p><ul><li>能够将日志同时输出到控制台与指定的文件中</li><li>输出的日志格式统一直观，能够直接定位到打印日志的源函数</li><li>有方便的日志宏例如<code>LOG_INFO(&quot;hello word x=&#123;0&#125;&quot;, 1)</code>打印日志</li><li>应用程序启动后初始化一次便可以全局使用</li></ul><p><strong>基于这些基本要求，封装了如下的帮助类：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: shengzu@wei</span><br><span class="hljs-comment"> * @Date: 2022-05-31 15:03:11</span><br><span class="hljs-comment"> * @LastEditTime: 2022-09-20 16:27:55</span><br><span class="hljs-comment"> * @LastEditors: shengzu@wei</span><br><span class="hljs-comment"> * @Description: logger_help.h</span><br><span class="hljs-comment"> * spdlog的简单封装，实现同时输出至控制台与文件中,c++文件包含此头文件后即可使用输出宏打印日志</span><br><span class="hljs-comment"> * 日志输出格式为：时间戳 进程id 线程id 运行环境 包名 日志级别 源文件名 行号</span><br><span class="hljs-comment"> * 日志内容 e.g. 2022.06.01-14:51:35.782 32992-7100 Windows core.sdk [info] [core.c++:47] hello word </span><br><span class="hljs-comment"> * 日志文件命名: 运行环境_日期_包名.log 且为循环日志每个日志最大10m </span><br><span class="hljs-comment"> * 日志文件输出e.g. 2022-06-01_core_sdk.log 2022-06-01_core_sdk.1.log 2022-06-01_core_sdk.2.log</span><br><span class="hljs-comment"> * 官方文档：https://github.com/gabime/spdlog/wiki</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;spdlog/async.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;spdlog/sinks/rotating_file_sink.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;spdlog/sinks/stdout_color_sinks.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;spdlog/spdlog.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_LEVEL_TRACE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_LEVEL_DEBUG 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_LEVEL_INFO 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_LEVEL_WARN 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_LEVEL_ERROR 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_LEVEL_CRITICAL 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_LEVEL_OFF 6</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(COMLOG_ACTIVE_LEVEL)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_ACTIVE_LEVEL COMLOG_LEVEL_DEBUG</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// use fmt lib, e.g. LOG_WARN(&quot;warn log, &#123;0&#125;, &#123;0&#125;, &#123;1&#125;&quot;, 0, 1);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMLOG_LOGGER_CALL(level, msg, ...)                                  \</span><br><span class="hljs-meta">  do &#123;                                                                       \</span><br><span class="hljs-meta">    auto deault_log = spdlog::default_logger_raw();                          \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (nullptr == deault_log) break;                                        \</span><br><span class="hljs-meta">    deault_log-&gt;log(spdlog::source_loc&#123;__FILE__, __LINE__, SPDLOG_FUNCTION&#125;, \</span><br><span class="hljs-meta">                    level, msg, ##__VA_ARGS__);                              \</span><br><span class="hljs-meta">  &#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> COMLOG_ACTIVE_LEVEL &lt;= COMLOG_LEVEL_TRACE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TRACE(msg, ...) \</span><br><span class="hljs-meta">  COMLOG_LOGGER_CALL(spdlog::level::trace, msg, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TRACE(msg, ...) (void)0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> COMLOG_ACTIVE_LEVEL &lt;= COMLOG_LEVEL_DEBUG</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_DEBUG(msg, ...) \</span><br><span class="hljs-meta">  COMLOG_LOGGER_CALL(spdlog::level::debug, msg, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_DEBUG(msg, ...) (void)0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> COMLOG_ACTIVE_LEVEL &lt;= COMLOG_LEVEL_INFO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_INFO(msg, ...) \</span><br><span class="hljs-meta">  COMLOG_LOGGER_CALL(spdlog::level::info, msg, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_INFO(msg, ...) (void)0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> COMLOG_ACTIVE_LEVEL &lt;= COMLOG_LEVEL_WARN</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_WARN(msg, ...) \</span><br><span class="hljs-meta">  COMLOG_LOGGER_CALL(spdlog::level::warn, msg, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_WARN(msg, ...) (void)0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> COMLOG_ACTIVE_LEVEL &lt;= COMLOG_LEVEL_ERROR</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ERROR(msg, ...) \</span><br><span class="hljs-meta">  COMLOG_LOGGER_CALL(spdlog::level::err, msg, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ERROR(msg, ...) (void)0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> COMLOG_ACTIVE_LEVEL &lt;= COMLOG_LEVEL_CRITICAL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_FATAL(msg, ...) \</span><br><span class="hljs-meta">  COMLOG_LOGGER_CALL(spdlog::level::critical, msg, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_FATAL(msg, ...) (void)0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-keyword">namespace</span> fs = std::filesystem;  <span class="hljs-comment">// c++17以上支持</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerHelp</span> <span class="hljs-keyword">final</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> LoggerHelp&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> LoggerHelp logger;  <span class="hljs-comment">// C++11 以上线程安全</span><br>    <span class="hljs-keyword">return</span> logger;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitLog</span><span class="hljs-params">(std::string log_file_path = <span class="hljs-string">&quot;&quot;</span>, std::string sys = <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               std::string package = <span class="hljs-string">&quot;&quot;</span>)</span> </span>&#123;<br>    log_file_path.<span class="hljs-built_in">empty</span>()<br>        ? log_file_path_ = fs::<span class="hljs-built_in">current_path</span>().<span class="hljs-built_in">u8string</span>().<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;/temp.log&quot;</span>)<br>        : log_file_path_ = log_file_path;<br>    sys.<span class="hljs-built_in">empty</span>() ? sys_name_ = <span class="hljs-string">&quot;UnknownSys&quot;</span> : sys_name_ = sys;<br>    package.<span class="hljs-built_in">empty</span>() ? package_name_ = <span class="hljs-string">&quot;UnknownPackage&quot;</span><br>                    : package_name_ = package;<br><br>    <span class="hljs-comment">// check log path and try to create log directory</span><br>    fs::path log_path = fs::<span class="hljs-built_in">u8path</span>(log_file_path_);<br>    fs::path log_dir = log_path.<span class="hljs-built_in">parent_path</span>();<br>    fs::path log_name = log_path.<span class="hljs-built_in">filename</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (!fs::<span class="hljs-built_in">exists</span>(log_path)) &#123;<br>        fs::<span class="hljs-built_in">create_directories</span>(log_dir);<br>      &#125;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> fs::filesystem_error&amp; ex) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Log file create failed: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>()<br>                &lt;&lt; <span class="hljs-string">&quot; file_name is: &quot;</span> &lt;&lt; log_file_path_ &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// initialize spdlog</span><br>      <span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> log_buffer_size = <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>;  <span class="hljs-comment">// 32kb</span><br>      spdlog::<span class="hljs-built_in">init_thread_pool</span>(log_buffer_size,<br>                               std::thread::<span class="hljs-built_in">hardware_concurrency</span>());<br>      std::vector&lt;spdlog::sink_ptr&gt; sinks;<br><br>      std::string date = <span class="hljs-built_in">GetCurrentDate</span>();<br>      std::string log_file =<br>          log_dir.<span class="hljs-built_in">string</span>() + <span class="hljs-string">&quot;/&quot;</span> + date + <span class="hljs-string">&quot;_&quot;</span> + log_name.<span class="hljs-built_in">string</span>();<br>      <span class="hljs-keyword">auto</span> file_sink = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(<br>          log_file, <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br>      <span class="hljs-keyword">auto</span> console_sink =<br>          std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();<br><br>      sinks.<span class="hljs-built_in">push_back</span>(file_sink);<br>      sinks.<span class="hljs-built_in">push_back</span>(console_sink);<br><br>      spdlog::<span class="hljs-built_in">set_default_logger</span>(<br>          std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;&quot;</span>, sinks.<span class="hljs-built_in">begin</span>(), sinks.<span class="hljs-built_in">end</span>()));<br>      spdlog::<span class="hljs-built_in">set_pattern</span>(<br>          <span class="hljs-string">&quot;%Y.%m.%d-%H:%M:%S.%e %P-%t &quot;</span> + sys_name_ + <span class="hljs-string">&quot; &quot;</span> + package_name_ +<br>          <span class="hljs-string">&quot; %^[%l]%$ [%s:%#] &quot;</span> +<br>          <span class="hljs-string">&quot;%v&quot;</span>);  <span class="hljs-comment">//设置日志输出格式,参考:https://github.com/gabime/spdlog/wiki/3.-Custom-formatting#customizing-format-using-set_pattern</span><br>      spdlog::<span class="hljs-built_in">flush_on</span>(spdlog::level::trace);<br>      spdlog::<span class="hljs-built_in">set_level</span>(spdlog::level::trace);<br><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> spdlog::spdlog_ex&amp; ex) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Log init failed: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>()<br>                &lt;&lt; <span class="hljs-string">&quot; file_name is: &quot;</span> &lt;&lt; log_file_path_ &lt;&lt; std::endl;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShutDown</span><span class="hljs-params">()</span> </span>&#123; spdlog::<span class="hljs-built_in">shutdown</span>(); &#125;<br><br>  <span class="hljs-function">std::string <span class="hljs-title">GetFilePath</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> log_file_path_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> std::string <span class="hljs-title">GetCurrentDate</span><span class="hljs-params">()</span> </span>&#123;<br>    std::<span class="hljs-type">time_t</span> timep;<br>    std::<span class="hljs-built_in">time</span>(&amp;timep);<br>    <span class="hljs-type">char</span> tmp[<span class="hljs-number">64</span>];<br>    <span class="hljs-built_in">strftime</span>(tmp, <span class="hljs-built_in">sizeof</span>(tmp), <span class="hljs-string">&quot;%Y-%m-%d&quot;</span>, std::<span class="hljs-built_in">localtime</span>(&amp;timep));<br>    <span class="hljs-keyword">return</span> tmp;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">LoggerHelp</span>() = <span class="hljs-keyword">default</span>;<br>  ~<span class="hljs-built_in">LoggerHelp</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-built_in">LoggerHelp</span>(<span class="hljs-type">const</span> LoggerHelp&amp;) = <span class="hljs-keyword">delete</span>;<br>  <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> LoggerHelp&amp;) = <span class="hljs-keyword">delete</span>;<br><br> <span class="hljs-keyword">private</span>:<br>  std::atomic_bool is_inited_&#123;<span class="hljs-literal">false</span>&#125;;<br>  std::string log_file_path_&#123;<span class="hljs-string">&quot;UNKNOWN&quot;</span>&#125;;<br>  std::string sys_name_&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>  std::string package_name_&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;logger_help.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LoggerHelp::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">InitLog</span>(<span class="hljs-string">&quot;D:/test.log&quot;</span>, <span class="hljs-string">&quot;Windows&quot;</span>, <span class="hljs-string">&quot;demo.sdk&quot;</span>);<br>    <span class="hljs-built_in">LOG_DEBUG</span>(<span class="hljs-string">&quot;hello word!&quot;</span>);<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Welcome to spdlog version &#123;0&#125;.&#123;1&#125;.&#123;2&#125;!&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    ...<br>        LoggerHelp::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">ShutDown</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输出如下:</span><br><span class="hljs-number">2022.09</span><span class="hljs-number">.23</span><span class="hljs-number">-17</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18.535</span> <span class="hljs-number">24836</span><span class="hljs-number">-25268</span> Windows demo.sdk [debug] [main.c++:<span class="hljs-number">5</span>] hello word!<br><span class="hljs-number">2022.09</span><span class="hljs-number">.23</span><span class="hljs-number">-17</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18.535</span> <span class="hljs-number">24836</span><span class="hljs-number">-24840</span> Windows demo.sdk [info] [main.c++:<span class="hljs-number">6</span>] Welcome to spdlog version <span class="hljs-number">1.1</span><span class="hljs-number">.0</span>!<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.<a href="https://spdlog.docsforge.com/v1.x/getting-started/">官方文档</a><br>2.<a href="https://www.cnblogs.com/yanke/p/3328402dd2e86456cd35cfcd8ec57198.html">spdlog简介</a><br>3.<a href="https://blog.nowcoder.net/n/0d037e9c27694b70bfecb2048d96f39e">spdlog 基本结构分析</a><br>4.<a href="https://blog.csdn.net/qq_39568245/article/details/115714105">spdlog使用</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>spdlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性笔记</title>
    <link href="/2022/08/10/C-2022-08-10-C-11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/10/C-2022-08-10-C-11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>C++11 是 C++ 程序设计语言标准的一个新的版本，在 2011 年由 ISO 批准并发布。C++11 新标准从而代替了原来的 C++98 和 C++03.。C++11 标准是对 C++ 的一次巨大的改进和扩充。在核心语法，STL 标准模板等方面增加众多新功能，新亮点。例如新增 auto，deltype，nullptr 等关键字，增加范围 for 循环，新增 lambda 表达式等。这里记录一下开发中常用的c++11新特性。</p><h2 id="更方便的列表初始化"><a href="#更方便的列表初始化" class="headerlink" title="更方便的列表初始化"></a>更方便的列表初始化</h2><p>C++11前只有数组能使用初始化列表。而C++11后大部分类型都可以初始化列表，方便的很，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> b = <span class="hljs-type">double</span>&#123;<span class="hljs-number">12.12</span>&#125;;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; iv&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::map&lt;<span class="hljs-type">int</span>, string&gt; temp&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>&#125;,&#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>&#125;&#125;;<br><span class="hljs-comment">//new</span><br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><h2 id="省心省力的自动类型推导"><a href="#省心省力的自动类型推导" class="headerlink" title="省心省力的自动类型推导"></a>省心省力的自动类型推导</h2><p>C++11中引入了auto，可以用来进行自动类型推导，不用关心数据类型，编译器会帮你推导好，而且这种方式也不影响编译速度。</p><p>比如迭代器使用了自动类型推导后，感觉清爽多了，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;const_iterator itor = vec.<span class="hljs-built_in">cbegin</span>(); itor != vec.<span class="hljs-built_in">cend</span>(); itor++);<br><span class="hljs-comment">//vec.cbegin()将返回std::vector&lt;int&gt;const_iterator类型</span><br><br>使用<span class="hljs-keyword">auto</span>:<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> itor = vec.<span class="hljs-built_in">cbegin</span>(); itor != vec.<span class="hljs-built_in">cend</span>(); itor++);<br></code></pre></td></tr></table></figure><p>不过，auto使用时也有需要注意的地方：<br>比如auto不能代表一个实际的类型声明，auto声明的变量必须<a href="https://blog.csdn.net/m_buddy/article/details/72828576">马上初始化</a>;</p><h2 id="简洁舒服的循环体-区间迭代（range-based-for-loop"><a href="#简洁舒服的循环体-区间迭代（range-based-for-loop" class="headerlink" title="简洁舒服的循环体(区间迭代（range-based for loop))"></a>简洁舒服的循环体(区间迭代（range-based for loop))</h2><p>for循环是使用频率非常高的循环方式，在新特性里我们不需要再像以前那样每次都使用自增或者自减的方式来索引了，结合前面介绍的auto，我们可以极大简化循环方式，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">旧方法：<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)<br>    std::cout &lt;&lt; arr[i];<br>新方法：<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : arr)<br>    std::cout &lt;&lt; n;<br>而且这种循环支持大部分数据类型，比如数组，容器，字符串，迭代器等等。<br>std::map&lt;string, <span class="hljs-type">int</span>&gt; temp&#123;&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : map)<br>    std::cout &lt;&lt; n.first &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; n.second &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>在上面的基于范围的for循环中，在n的定义之后，紧跟一个冒号(:)，之后直接写上需要遍历的表达式，for循环将自动以表达式返回的容器为范围进行迭代;<br>需要注意<br>1.在上面的例子中，我们都是在使用只读方式遍历容器。如果需要在遍历时修改容器中的值，则需要如下使用引用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span>&amp; n : arr)&#123;<br>    cout&lt;&lt; n++ &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.若只是希望遍历，而不希望修改，可以使用const auto&amp;来定义n的类型。这样对于复制负担比较大的容器元素（比如一个std::vector<a href="std::string">std::string</a>数组)也可以无损耗地进行遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; arr=&#123;<span class="hljs-string">&quot;li ming&quot;</span>,<span class="hljs-string">&quot;wang lei&quot;</span>,<span class="hljs-string">&quot;han meimei&quot;</span>&#125;；<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; n : arr)&#123;<br>    cout&lt;&lt;arr&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>更多可参考<a href="https://blog.csdn.net/fjzpdkf/article/details/50249249">for循环的使用细节</a></p><h2 id="随心所欲可变长的参数模板"><a href="#随心所欲可变长的参数模板" class="headerlink" title="随心所欲可变长的参数模板"></a>随心所欲可变长的参数模板</h2><p>在Python和MATLAB中可以非常方便的使用可以变长的参数，C++11以后引入了tuple，可以实现类似功能，并且可以传入多个不同类型的数据，如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//支持多种不同类型数据</span><br><span class="hljs-keyword">auto</span> tup1 = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-string">&quot;Hello Word!&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3.14</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//方便拆分</span><br><span class="hljs-keyword">auto</span> tup1 = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">3.14</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>);<br><span class="hljs-type">double</span> a; <span class="hljs-type">int</span> b; std::string c;<br>std::<span class="hljs-built_in">tie</span>(a, b, c) = tup1; <span class="hljs-comment">// a=3.14, b=1, c=test</span><br><br><span class="hljs-comment">//方便链接</span><br><span class="hljs-function">std::tuple&lt;<span class="hljs-type">float</span>, string&gt; <span class="hljs-title">tup1</span><span class="hljs-params">(<span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;test&quot;</span>)</span></span>;<br><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;  <span class="hljs-title">tup2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br><span class="hljs-keyword">auto</span> tupl3 = <span class="hljs-built_in">tuple_cat</span>(tup1, tup2);<br></code></pre></td></tr></table></figure><h2 id="nullptr关键字及用法"><a href="#nullptr关键字及用法" class="headerlink" title="nullptr关键字及用法"></a>nullptr关键字及用法</h2><p><strong>为什么需要nullptr? NULL有什么毛病？</strong><br>我们通过下面一个小小的例子来发现NULL的一点问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestWork</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TestWork 1&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestWork</span><span class="hljs-params">(<span class="hljs-type">int</span> * index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TestWork 2&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test test;<br>    test.<span class="hljs-built_in">TestWork</span>(<span class="hljs-literal">NULL</span>);<br>    test.<span class="hljs-built_in">TestWork</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br>运行结果：<br>    TestWork <span class="hljs-number">1</span><br>    TestWork <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>NULL在c++里表示空指针，看到问题了吧，我们调用test.TestWork(NULL)，其实期望是调用的是void TestWork(int * index)，但结果调用了voidTestWork(int index)。但使用nullptr的时候，我们能调用到正确的函数。</p><h2 id="Enum-Class"><a href="#Enum-Class" class="headerlink" title="Enum Class"></a>Enum Class</h2><h3 id="传统的enum关键字"><a href="#传统的enum关键字" class="headerlink" title="传统的enum关键字"></a>传统的enum关键字</h3><p>不管是c语言，还是c++语言， 其中都有enum关键字。这是这两种语言的基础知识中都会涉及到的点。<br>其具体定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">my_enum</span><br>&#123;<br>    my_enum1 = <span class="hljs-number">0</span>,<br>    my_enum2,<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然也可以省略 enum的名字，使用匿名的方式定义枚举，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span><br>&#123;<br>    my_enum1 = <span class="hljs-number">0</span>,<br>    my_enum2,<br>&#125;;<br></code></pre></td></tr></table></figure><p>或者与 ‘typedef’ 关键字联合使用，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <br>&#123;<br>    my_enum1 = <span class="hljs-number">0</span>,<br>    my_enum2,<br>&#125;my_enum;<br></code></pre></td></tr></table></figure><h3 id="传统enum关键字存在的问题"><a href="#传统enum关键字存在的问题" class="headerlink" title="传统enum关键字存在的问题"></a>传统enum关键字存在的问题</h3><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>传统的enum关键字的作用域是全局的，也就是说，如果在enum A中声明的一个枚举类型my_enum3，无法在enum B中声明同样的枚举类型，具体的就是，如下的写法是错误的，会出现编译错误(会报 重定义错误)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">A</span><br>&#123;<br>    my_enum3 = <span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">B</span><br>&#123;<br>    my_enum3 = <span class="hljs-number">0</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="能隐式转换为其他类型-如整型"><a href="#能隐式转换为其他类型-如整型" class="headerlink" title="能隐式转换为其他类型(如整型)"></a>能隐式转换为其他类型(如整型)</h4><p>具体如下面的代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">my_enum</span><br>&#123;<br>    my_enum1 = <span class="hljs-number">0</span>,<br>    my_enum2,<br><br>&#125;;<br><br><span class="hljs-type">int</span> my_int = my_enum1;<br></code></pre></td></tr></table></figure><h4 id="无法指定底层使用的数据类型"><a href="#无法指定底层使用的数据类型" class="headerlink" title="无法指定底层使用的数据类型"></a>无法指定底层使用的数据类型</h4><p>也就是说，无法明确的知道，一个枚举类型，占用内存的字节数，这样在结构体中使用enum的时候就可能遇到麻烦， 特别是结构体需要内存对齐或者填充处理的时候问题就尤为突出了。</p><h3 id="奇妙的enum-class，enum-struct组合"><a href="#奇妙的enum-class，enum-struct组合" class="headerlink" title="奇妙的enum class，enum struct组合"></a>奇妙的enum class，enum struct组合</h3><p>在c++11标准中，除了传统的enum关键字之外， 还新增了一个概念： enum class， enum struct组合的形式(两者是等价的)，当然单纯的enum关键字和enum class组合并不冲突，都能使用。 这一组合的出现就是为了解决传统enum关键字面临的问题。<br>    enum class组合具有class封装性的特性，作用域是确定的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    my_enum3 = <span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    my_enum3 = <span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">C</span><br>&#123;<br>    my_enum3 = <span class="hljs-number">0</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上面这样声明和定义枚举就是正确的，要访问A和B中的枚举是需要加上作用域的，形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>A a = A::my_enum3;<br>B b = B::my_enum3;<br></code></pre></td></tr></table></figure><p>    可以指定底层数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">A</span>: <span class="hljs-type">int</span> <span class="hljs-comment">/** 每个枚举都是int类型的 */</span><br>&#123;<br>    my_enum3 = <span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">B</span>: <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-comment">/** 每个枚举都是unsigned char类型的 */</span><br>&#123;<br>    my_enum3 = <span class="hljs-number">0</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>    不能隐式转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">int</span> my_int = A::my_enum3; <span class="hljs-comment">/** 错误，无法通过编译 */</span><br><span class="hljs-type">int</span> my_int = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(A::my_enum3); <span class="hljs-comment">/** 正确， 可以通过编译 */</span><br></code></pre></td></tr></table></figure><p>enum class， enum struct组合的出现可以极大的增加枚举类型使用的灵活性，安全性以及易用性;枚举量的作用域为类后，不同枚举定义中的枚举量就不会发生冲突了,这样在枚举中就只需要关注枚举代表的内容，不需要去区分前缀或是否重定义等问题。</p><h2 id="override与final"><a href="#override与final" class="headerlink" title="override与final"></a>override与final</h2><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>当你在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> :<span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//OK</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// OK</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">//OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果不使用override，当你手一抖，将**foo()<strong>写成了</strong>f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。<br>　　所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> :A<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f00</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//OK</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0o</span><span class="hljs-params">()</span><span class="hljs-keyword">override</span></span>; <span class="hljs-comment">//Error </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>为了减少程序的运行时错误，还是养成重写虚函数加上override的习惯吧。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : Base<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>; <span class="hljs-comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>; <span class="hljs-comment">// Error: 父类中没有 bar虚函数可以被重写或final</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">final</span> : A <span class="hljs-comment">// 指明B是不可以被继承的</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// Error: 在A中已经被final了</span><br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : B <span class="hljs-comment">// Error: B is final</span><br>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Lamdba表达式"><a href="#Lamdba表达式" class="headerlink" title="Lamdba表达式"></a>Lamdba表达式</h2><p><code>lambda</code>表达式是<code>C++11</code>中引入的一项新技术，利用<code>lambda</code>表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。但是从本质上来讲，<code>lambda</code>表达式只是一种语法糖，因为所有其能完成的工作都可以用其它稍微复杂的代码来实现。但是它简便的语法却给<code>C++</code>带来了深远的影响。如果从广义上说，<code>lamdba</code>表达式产生的是函数对象。在类中，可以重载函数调用运算符<code>()</code>，此时类的对象可以将具有类似函数的行为，我们称这些对象为函数对象（Function Object）或者仿函数（Functor）。相比<code>lambda</code>表达式，函数对象有自己独特的优势。</p><h3 id="lambda表达式用法"><a href="#lambda表达式用法" class="headerlink" title="lambda表达式用法"></a>lambda表达式用法</h3><p>我们先从简单的例子开始，我们定义一个可以输出字符串的lambda表达式，表达式一般都是从方括号[]开始，然后结束于花括号{}，花括号里面就像定义函数那样，包含了lamdba表达式体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义简单的lambda表达式</span><br><span class="hljs-keyword">auto</span> basicLambda = [] &#123; cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!&quot;</span> &lt;&lt; endl; &#125;;<br><span class="hljs-comment">// 调用</span><br><span class="hljs-built_in">basicLambda</span>();   <span class="hljs-comment">// 输出：Hello, world!</span><br></code></pre></td></tr></table></figure><p>上面是最简单的lambda表达式，没有参数。如果需要参数，那么就要像函数那样，放在圆括号里面，如果有返回值，返回类型要放在-&gt;后面，即拖尾返回类型，当然你也可以忽略返回类型，lambda会帮你自动推断出返回类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 指明返回类型</span><br><span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br><span class="hljs-comment">// 自动推断返回类型</span><br><span class="hljs-keyword">auto</span> multiply = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a * b; &#125;;<br><br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);   <span class="hljs-comment">// 输出：7</span><br><span class="hljs-type">int</span> product = <span class="hljs-built_in">multiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 输出：10</span><br></code></pre></td></tr></table></figure><p>大家可能会想lambda表达式最前面的方括号的意义何在？其实这是lambda表达式一个很要的功能，就是闭包。这里我们先讲一下lambda表达式的大致原理：每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符，我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">auto</span> add_x = [x](<span class="hljs-type">int</span> a) &#123; <span class="hljs-keyword">return</span> a + x; &#125;;  <span class="hljs-comment">// 复制捕捉x</span><br>    <span class="hljs-keyword">auto</span> multiply_x = [&amp;x](<span class="hljs-type">int</span> a) &#123; <span class="hljs-keyword">return</span> a * x; &#125;;  <span class="hljs-comment">// 引用捕捉x</span><br>    <br>    cout &lt;&lt; <span class="hljs-built_in">add_x</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">multiply_x</span>(<span class="hljs-number">10</span>) &lt;&lt; endl;<br>    <span class="hljs-comment">// 输出：20 100</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当lambda捕捉块为空时，表示没有捕捉任何变量。但是上面的add_x是以复制的形式捕捉变量x，而multiply是以引用的方式捕捉x。前面讲过，lambda表达式是产生一个闭包类，那么捕捉是回事？对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。前面说过，闭包类也实现了函数调用运算符的重载，一般情况是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosureType</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function">ReturnType <span class="hljs-title">operator</span><span class="hljs-params">(params)</span> <span class="hljs-type">const</span> </span>&#123; body &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这意味着lambda表达式无法修改通过复制形式捕捉的变量，因为函数调用运算符的重载方法是const属性的。有时候，你想改动传值方式捕获的值，那么就要使用mutable，例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">auto</span> add_x = [x](<span class="hljs-type">int</span> a) <span class="hljs-keyword">mutable</span> &#123; x *= <span class="hljs-number">2</span>; <span class="hljs-keyword">return</span> a + x; &#125;;  <span class="hljs-comment">// 复制捕捉x</span><br>    <br>    cout &lt;&lt; <span class="hljs-built_in">add_x</span>(<span class="hljs-number">10</span>) &lt;&lt; endl; <span class="hljs-comment">// 输出 30</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是为什么呢？因为你一旦将lambda表达式标记为mutable，那么实现的了函数调用运算符是非const属性的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosureType</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function">ReturnType <span class="hljs-title">operator</span><span class="hljs-params">(params)</span> </span>&#123; body &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，看来与具体实现有关。既然说到了深处，还有一点要注意：lambda表达式是不能被赋值的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> a = [] &#123; cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; endl; &#125;;<br><span class="hljs-keyword">auto</span> b = [] &#123; cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span> &lt;&lt; endl; &#125;;<br><br>a = b;   <span class="hljs-comment">// 非法，lambda无法赋值</span><br><span class="hljs-keyword">auto</span> c = a;   <span class="hljs-comment">// 合法，生成一个副本</span><br></code></pre></td></tr></table></figure><p>你可能会想a与b对应的函数类型是一致的（编译器也显示是相同类型：lambda [] void () -&gt; void），为什么不能相互赋值呢？因为禁用了赋值操作符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ClosureType&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ClosureType&amp;) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><p>但是没有禁用复制构造函数，所以你仍然可以用一个lambda表达式去初始化另外一个lambda表达式而产生副本。并且lambda表达式也可以赋值给相对应的函数指针，这也使得你完全可以把lambda表达式看成对应函数类型的指针。<br>       闲话少说，归入正题，捕获的方式可以是引用也可以是复制，但是具体说来会有以下几种情况来捕获其所在作用域中的变量：<br>[]：默认不捕获任何变量；<br>      [&#x3D;]：默认以值捕获所有变量；<br>      [&amp;]：默认以引用捕获所有变量；<br>      [x]：仅以值捕获x，其它变量不捕获；<br>      [&amp;x]：仅以引用捕获x，其它变量不捕获；<br>      [&#x3D;, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；<br>      [&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；<br>      [this]：通过引用捕获当前对象（其实是复制指针）；<br>      [*this]：通过传值方式捕获当前对象；</p><p>在上面的捕获方式中，注意最好不要使用[&#x3D;]和[&amp;]默认捕获所有变量。首先说默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的声明周期：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::function&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">add_x</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> [&amp;](<span class="hljs-type">int</span> a) &#123; <span class="hljs-keyword">return</span> x + a; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为参数x仅是一个临时变量，函数调用后就被销毁，但是返回的lambda表达式却引用了该变量，但调用这个表达式时，引用的是一个垃圾值，所以会产生没有意义的结果。你可能会想，可以通过传值的方式来解决上面的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::function&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">add_x</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> [=](<span class="hljs-type">int</span> a) &#123; <span class="hljs-keyword">return</span> x + a; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>是的，使用默认传值方式可以避免悬挂引用问题。但是采用默认值捕获所有变量仍然有风险，看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Filter</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Filter</span>(<span class="hljs-type">int</span> divisorVal):<br>    divisor&#123;divisorVal&#125;<br>    &#123;&#125;<br><br>    <span class="hljs-function">std::function&lt;<span class="hljs-title">bool</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">getFilter</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> [=](<span class="hljs-type">int</span> value) &#123;<span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;;<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> divisor;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类中有一个成员方法，可以返回一个lambda表达式，这个表达式使用了类的数据成员divisor。而且采用默认值方式捕捉所有变量。你可能认为这个lambda表达式也捕捉了divisor的一份副本，但是实际上大错特错。问题出现在哪里呢？因为数据成员divisor对lambda表达式并不可见，你可以用下面的代码验证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围</span><br><span class="hljs-function">std::function&lt;<span class="hljs-title">bool</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">getFilter</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> [divisor](<span class="hljs-type">int</span> value) &#123;<span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么原来的代码为什么能够捕捉到呢？仔细想想，原来每个非静态方法都有一个this指针变量，利用this指针，你可以接近任何成员变量，所以lambda表达式实际上捕捉的是this指针的副本，所以原来的代码等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::function&lt;<span class="hljs-title">bool</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">getFilter</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>](<span class="hljs-type">int</span> value) &#123;<span class="hljs-keyword">return</span> value % <span class="hljs-keyword">this</span>-&gt;divisor == <span class="hljs-number">0</span>; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，所以lambda表达式的闭包与一个类对象绑定在一起了，这也很危险，因为你仍然有可能在类对象析构后使用这个lambda表达式，那么类似“悬挂引用”的问题也会产生。所以，采用默认值捕捉所有变量仍然是不安全的，主要是由于指针变量的复制，实际上还是按引用传值。<br>      通过前面的例子，你还可以看到lambda表达式可以作为返回值。我们知道lambda表达式可以赋值给对应类型的函数指针。但是使用函数指针貌似并不是那么方便。所以STL定义在头文件提供了一个多态的函数对象封装std::function，其类似于函数指针。它可以绑定任何类函数对象，只要参数与返回类型相同。如下面的返回一个bool且接收两个int的函数包装器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; wrapper = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x &lt; y; &#125;;<br></code></pre></td></tr></table></figure><p>而lambda表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数。其实，最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量，通过lambda表达式给出条件，传递给count_if函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value = <span class="hljs-number">3</span>;<br>vector v &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>&#125;;<br><span class="hljs-type">int</span> count = std::<span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">beigin</span>(), v.<span class="hljs-built_in">end</span>(), [value](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x &gt; value; &#125;);<br></code></pre></td></tr></table></figure><p>总之，对于大部分STL算法，可以非常灵活地搭配lambda表达式来实现想要的效果。<br>前面讲完了lambda表达式的基本使用，最后给出lambda表达式的完整语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 完整语法</span><br>[ capture-list ] ( params ) <span class="hljs-built_in">mutable</span>(optional) <span class="hljs-built_in">constexpr</span>(optional)(c++<span class="hljs-number">17</span>) exception attribute -&gt; ret &#123; body &#125;<br><br><span class="hljs-comment">// 可选的简化语法</span><br>[ capture-list ] ( params ) -&gt; ret &#123; body &#125;<br>[ capture-list ] ( params ) &#123; body &#125;<br>[ capture-list ] &#123; body &#125;<br></code></pre></td></tr></table></figure><p>第一个是完整的语法，后面3个是可选的语法。这意味着lambda表达式相当灵活，但是照样有一定的限制，比如你使用了拖尾返回类型，那么就不能省略参数列表，尽管其可能是空的。针对完整的语法，我们对各个部分做一个说明：</p><p>capture-list：捕捉列表，这个不用多说，前面已经讲过，记住它不能省略；</p><p>params：参数列表，可以省略（但是后面必须紧跟函数体）；</p><p>mutable：可选，将lambda表达式标记为mutable后，函数体就可以修改传值方式捕获的变量；</p><p>constexpr：可选，C++17，可以指定lambda表达式是一个常量函数；</p><p>exception：可选，指定lambda表达式可以抛出的异常；</p><p>attribute：可选，指定lambda表达式的特性；</p><p>ret：可选，返回值类型；</p><p>body：函数执行体。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://www.cnblogs.com/feng-sc/p/5710724.html#title31">C++11常用特性的使用经验总结</a><br>2.<a href="https://blog.csdn.net/xuanwolanxue/article/details/79801038">奇妙的enum class，enum struct组合_玄道公子的博客-CSDN博客</a><br>3.<a href="https://www.jianshu.com/p/d686ad9de817">C++ lambda表达式与函数对象</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>c++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在C++中如何调用qml方法</title>
    <link href="/2022/07/16/Qt-2022-07-16-C-%E8%B0%83%E7%94%A8qml/"/>
    <url>/2022/07/16/Qt-2022-07-16-C-%E8%B0%83%E7%94%A8qml/</url>
    
    <content type="html"><![CDATA[<p>所有QML的函数(方法)都暴露在元对象系统中，并且在C++中可以使用<a href="https://doc.qt.io/qt-5/qmetaobject.html#invokeMethod">QMetaObject::invokeMethod</a>调用，若函数存在返回值则<strong>可指定参数的类型和冒号字符后的返回值</strong>，如下面的代码段所示:</p><ul><li><p>qml代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MyItem.qml</span><br><span class="hljs-keyword">import</span> QtQuick <span class="hljs-number">2.0</span><br><br>Item &#123;<br>    <span class="hljs-function">function <span class="hljs-title">myQmlFunction</span><span class="hljs-params">(msg: string)</span> : string &#123;</span><br>        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Got message:&quot;</span>, msg)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;some return value&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>c++代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br>QQmlEngine engine;<br><span class="hljs-function">QQmlComponent <span class="hljs-title">component</span><span class="hljs-params">(&amp;engine, <span class="hljs-string">&quot;MyItem.qml&quot;</span>)</span></span>;<br>QObject *object = component.<span class="hljs-built_in">create</span>();<br><br>QString returnedValue;<br>QString msg = <span class="hljs-string">&quot;Hello from C++&quot;</span>;<br>QMetaObject::<span class="hljs-built_in">invokeMethod</span>(object, <span class="hljs-string">&quot;myQmlFunction&quot;</span>,<br>        <span class="hljs-built_in">Q_RETURN_ARG</span>(QString, returnedValue),<br>        <span class="hljs-built_in">Q_ARG</span>(QString, msg));<br><br><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;QML function returned:&quot;</span> &lt;&lt; returnedValue;<br><span class="hljs-keyword">delete</span> object;<br></code></pre></td></tr></table></figure></li></ul><p>注：若qml中fuction函数参数及返回值未指定类型则<a href="https://doc.qt.io/archives/qt-5.10/qmetaobject.html#invokeMethod">QMetaObject::invokeMethod</a> ()的<a href="https://doc.qt.io/archives/qt-5.10/qmetaobject.html#Q_RETURN_ARG">Q_RETURN_ARG</a> () 和<a href="https://doc.qt.io/archives/qt-5.10/qmetaobject.html#Q_ARG">Q_ARG</a> () 参数必须指定为<a href="https://doc.qt.io/archives/qt-5.10/qvariant.html">QVariant</a>类型，因为这是用于 QML 方法参数和返回值的通用数据类型，参考：<a href="https://doc.qt.io/archives/qt-5.10/qtqml-cppintegration-interactqmlfromcpp.html">https://doc.qt.io/archives/qt-5.10/qtqml-cppintegration-interactqmlfromcpp.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>qt</tag>
      
      <tag>qml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective /More Effective C++阅读笔记</title>
    <link href="/2022/07/08/C-2022-07-08-Effective-C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/08/C-2022-07-08-Effective-C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>有人说C++程序员可以分为两类，读过Effective C++的和没读过的。世界C++大师Scott Meyers成名之作的确当得起这样的评价。读完这本书后让我茅塞顿开，宛如一下打通了我的任督二脉，许多以往看别人代码一知半解的问题都有了答案，知其然又知其所以然的感觉不要太好，这里简单记录一下其中的一些条款方便复习。</p><h2 id="1-最好使用C-转型操作符"><a href="#1-最好使用C-转型操作符" class="headerlink" title="1.最好使用C++ 转型操作符"></a>1.最好使用C++ 转型操作符</h2><p>隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，提示程序员这一步有转换，是怎么样的转换，作用类似于注释，因为如果我们不用显式的类型转换，隐形的也可以完成一些转换，但是我们不会意识到，这就有可能造成危险。 但是，这种强调风险的方式还是比较粗放，它并没有表明存在什么风险，风险程度如何。<br>    再者，C风格的强制类型转换统一使用( )，而( )在代码中随处可见，所以也不利于使用文本检索工具(例如 Windows 下的 Ctrl+F、Linux 下的 grep 命令、Mac 下的 Command+F)定位关键代码。为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持。<br><strong>从可读性和规范来说，不应该使用C语言的转型了，而应该使用以下四种转型操作符。</strong></p><table><thead><tr><th></th><th>static_cast<T>()</th><th>const_cast<T>()</th><th>dynamic_cast<T>()</th><th>reinterpret_cast<T>()</th></tr></thead><tbody><tr><td>操作</td><td>普通转型操作</td><td>去除某个对象的常量性</td><td>继承体系中安全的向下转型或者跨系转型</td><td>用来转换不同指针的类型</td></tr><tr><td>注意事项</td><td>与C语言旧式转型有相同威力与意义</td><td></td><td>只能用于继承体系中</td><td>不具备移植性,尽量避免使用</td></tr></tbody></table><blockquote><ul><li>dynamic_cast 可以把指向基类的指针或者引用转换为指向派生类的指针或者引用，若转型失败，会以一个null指针（当转型对象是指针）或一个exception（当转型对象是引用）表现出来</li></ul></blockquote><hr><h2 id="2-尽可能使用const"><a href="#2-尽可能使用const" class="headerlink" title="2.尽可能使用const"></a>2.尽可能使用const</h2><p>将某些东西声明为const可帮助编译器侦测出错误用法，const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体；</p><ul><li>关键字const出现在星号左边，表示被指物是常量；出现在星号右边，表示指针自身是常量；出现在星号两边，表示被指物和指针两者都是常量；</li><li>const定义接口，防止误用；</li><li>非内置类型参数传递采用const引用提升效率；</li><li>const成员函数不可以修改任何非non-static成员变量(<strong>mutable修饰的变量除外</strong>)，不能调用非const成员函数，因为非const成员函数可能修改成员变量;</li><li>const不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例;</li></ul><h2 id="3-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#3-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="3.若不想使用编译器自动生成的函数，就该明确拒绝"></a>3.若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>将默认生成的函数声明为private，或者C++ 11新特性”&#x3D;delete”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;);<br>    Uncopyable&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-绝对不要以多态的方式处理数组"><a href="#4-绝对不要以多态的方式处理数组" class="headerlink" title="4.绝对不要以多态的方式处理数组"></a>4.绝对不要以多态的方式处理数组</h2><p>如果用基类的数组存派生类对象，因为基类对象占用的内存和派生类对象占用内存大小不一样（由于derived calsses 通常比其base classes有更多的data members）会导致寻址出错,结果不可预期;析构也会出错，通过base class 的指针删除derived classes 的对象构成的数组，结果未定义;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span>&#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BalanceBST</span>:<span class="hljs-keyword">public</span> BST&#123;...&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBstArray</span><span class="hljs-params">(ostream &amp;s,<span class="hljs-type">const</span> BST array[],<span class="hljs-type">int</span> numElements)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; numElements;++i) &#123;<br>    s&lt;&lt;array[i]&lt;&lt;endl; <span class="hljs-comment">//*(array + i) 内存地址为i*sizeof(BST)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BST BSTArray[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">printBstArray</span>(cout, BSTArray, <span class="hljs-number">10</span>); <span class="hljs-comment">//没问题，运行良好</span><br>    <br>    BalanceBST bBSTArray[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">printBstArray</span>(cout, bBSTArray, <span class="hljs-number">10</span>); <span class="hljs-comment">//错误用法,寻址出错结果不可预期</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>数组对象几乎总会涉及指针的算术运算，所以数组和多态不要混用;</strong></li></ul><h2 id="5-复制对象时务忘其每一个成分"><a href="#5-复制对象时务忘其每一个成分" class="headerlink" title="5.复制对象时务忘其每一个成分"></a>5.复制对象时务忘其每一个成分</h2><ul><li>记得实现拷贝构造函数和赋值操作符的时候，复制所有local成员变量以及调用base内适当的copying函数;</li><li>令赋值操作符调用拷贝构造函数是不合理的，可以让拷贝构造函数和赋值操作符调用一个共同的函数，例如init;</li></ul><h2 id="6-以独立的语句将newed对象置入智能指针"><a href="#6-以独立的语句将newed对象置入智能指针" class="headerlink" title="6.以独立的语句将newed对象置入智能指针"></a>6.以独立的语句将newed对象置入智能指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">proccessWidget</span><span class="hljs-params">(std::shared_ptr&lt;Widget&gt;pw, <span class="hljs-type">int</span> pi)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">proccessWidget</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">priority</span>()); <span class="hljs-comment">//错误用法，可能泄露资源</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    在调用proccessWidget之前，编译器会创建代码做以下三件事：</span><br><span class="hljs-comment">    1.调用priority</span><br><span class="hljs-comment">    2.执行“new Widget”</span><br><span class="hljs-comment">    3.调用std::shared_ptr构造函数</span><br><span class="hljs-comment">    c++编译器以什么样的次序完成以上三件事是不定的（只能确定2在3前）;若调用顺序为2-&gt;1-&gt;3,此时若对</span><br><span class="hljs-comment">    priority调用产生异常,&quot;new Widget&quot;返回的指针将会遗失，因为它尚未被置入智能指针;</span><br><span class="hljs-comment">    */</span><br>    <br>    std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget) <span class="hljs-built_in">pw</span>(<span class="hljs-keyword">new</span> Widget); <span class="hljs-comment">//正确，在单独语句内以智能指针存储new对象</span><br>    <span class="hljs-built_in">proccessWidget</span>(pw, <span class="hljs-built_in">priority</span>()); <span class="hljs-comment">//这个调用绝不会发生内存泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>以独立语句将newed对象存储于（置入）智能指针内，如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露</strong></li></ul><h2 id="7-对定制的“类型转换函数”保持警觉（explict关键字用法）"><a href="#7-对定制的“类型转换函数”保持警觉（explict关键字用法）" class="headerlink" title="7.对定制的“类型转换函数”保持警觉（explict关键字用法）"></a>7.对定制的“类型转换函数”保持警觉（explict关键字用法）</h2><p>c++允许编译器在不同类型之间执行隐式转换（implicit conversions）,两种函数允许编译器执行这样的转换： <strong>隐式类型转换操作符与单自变量构造函数；</strong>它们的出现可能导致非预期的函数被调用。</p><h4 id="a-隐式类型转换操作符：关键词operator之后加上一个类型名称"><a href="#a-隐式类型转换操作符：关键词operator之后加上一个类型名称" class="headerlink" title="a.隐式类型转换操作符：关键词operator之后加上一个类型名称"></a>a.隐式类型转换操作符：关键词operator之后加上一个类型名称</h4><p>例如，为了让<strong>Rational objects</strong>能够被隐式转换为double类型你可能定义<strong>class</strong> <strong>Rational</strong>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//将Rational转换为double</span><br>    <span class="hljs-comment">//未重载operator &lt;&lt;</span><br>&#125;;<br><br><span class="hljs-comment">//这个函数会在以下情况被自动调用：</span><br><span class="hljs-function">Rational <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">//r的值是1/2</span><br><span class="hljs-type">double</span> d = <span class="hljs-number">0.5</span> * r;<span class="hljs-comment">//将r转换为double,然后执行乘法运算</span><br></code></pre></td></tr></table></figure><p>考虑如下情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Rational <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>std::cout &lt;&lt; r;<span class="hljs-comment">//期望输出1/2</span><br></code></pre></td></tr></table></figure><p>假设你忘记为了Rational写一个<strong>operator&lt;&lt;</strong>,你或许会以为上述打印动作不会成功，但本例中你的编译器发现，只要调用<strong>Rational::operator double</strong>,将r隐式转换为double,调用便能成功，于是r将以浮点数而非分数形式输出。<br>解决方法：以功能对等的另一个函数取代类型转换操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">asDouble</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//将Rational转换为double</span><br>&#125;;<br><br><span class="hljs-function">Rational <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>std::cout &lt;&lt; r;  <span class="hljs-comment">//错误!Rational没有operator&lt;&lt;</span><br>std::cout &lt;&lt; r.<span class="hljs-built_in">asDouble</span>();  <span class="hljs-comment">//可!以double的形式输出r</span><br></code></pre></td></tr></table></figure><p>这或许便是为什么**std::sting类型并未含有“从string object至char *的隐式转换函数”的原因**。</p><h4 id="b-单自变量构造函数：指能够以单一自变量成功调用的构造函数"><a href="#b-单自变量构造函数：指能够以单一自变量成功调用的构造函数" class="headerlink" title="b.单自变量构造函数：指能够以单一自变量成功调用的构造函数"></a>b.单自变量构造函数：指能够以单一自变量成功调用的构造函数</h4><p>如此的构造函数可能声明拥有单一参数，也可能声明拥有多个参数，并且除了第一参数之外都有默认值。例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*单自变量构造函数:单一参数或除了第一参数之外都有默认值*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Name</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Name</span>(<span class="hljs-type">const</span> std::string &amp;s); <span class="hljs-comment">//可以把string转换为Name</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>); <span class="hljs-comment">//可以把int转换为Rational</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>单类拥有单自变量构造时，考虑一个例子，一个针对数组结构而写的<strong>class template</strong>,这些数组允许用户指定索引值的上限和下限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-type">int</span> lowBound, <span class="hljs-type">int</span> highBound); <span class="hljs-comment">//允许用户指定上限和下限</span><br>    <span class="hljs-built_in">Array</span>(<span class="hljs-type">int</span> size); <span class="hljs-comment">//允许用户指定数组的元素个数</span><br>    <br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index);<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Array&lt;<span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> Array&lt;<span class="hljs-type">int</span>&gt;&amp; rhs);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Array&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Array&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (a == b[i]) &#123;<span class="hljs-comment">//注意：&quot;a&quot;原本应是&quot;a[i]&quot;才对</span><br>            <span class="hljs-comment">//do something</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码将类型为Array<int>的自变量a和类型为int的自变量b[i]比较，编译时当然期望编译器能发挥挑错功能，但编译器注意到，只要调用Array<int>需要一个int作为自变量的构造函数，它就可以将int转换为Array<int> object,于是便产生类似这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">static_cast</span>&lt;Array&lt;<span class="hljs-type">int</span>&gt;&gt;(b[i])) ...<br></code></pre></td></tr></table></figure><p>结果显然偏离预期，要解决该类问题最简易的方法为：<strong>单自变量构造函数前加explicit关键字禁止编译器进行隐式转换。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-type">int</span> lowBound, <span class="hljs-type">int</span> highBound);<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Array</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<span class="hljs-comment">//禁止隐式转换</span><br>    <br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index);<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Array&lt;<span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> Array&lt;<span class="hljs-type">int</span>&gt;&amp; rhs);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="8-区别increment-x2F-decrement-–-操作符的前置与后置形式"><a href="#8-区别increment-x2F-decrement-–-操作符的前置与后置形式" class="headerlink" title="8.区别increment(++)&#x2F;decrement(–)操作符的前置与后置形式"></a>8.区别increment(++)&#x2F;decrement(–)操作符的前置与后置形式</h2><p>重载函数是以其参数类型来区分彼此的，然而不论++或–操作符的前置式或后置式都没有参数，为了区别它们，后置式的有一个int自变量（不使用），并且在它被调用时，编译器默默地为该int指定一个0值；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UPInt</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    UPInt&amp; <span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">//前置式++</span><br>    <span class="hljs-type">const</span> UPInt <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">//后置式++</span><br>    <br>    UPInt&amp; <span class="hljs-keyword">operator</span>--(); <span class="hljs-comment">//前置式--</span><br>    <span class="hljs-type">const</span> UPInt <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>); <span class="hljs-comment">//后置式--</span><br>&#125;<br><span class="hljs-comment">//前置式：累加然后取出(increment and fetch)</span><br>UPInt&amp; UPInt::<span class="hljs-keyword">operator</span>++()<br>&#123;<br>    *<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//后置式：取出然后累加(fetch and increment)</span><br><span class="hljs-function"><span class="hljs-type">const</span> UPInt <span class="hljs-title">UPInt::operator</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    UPInt oldValue = *<span class="hljs-keyword">this</span>;<br>    ++(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>前置式返回一个引用，后置式返回一个const对象；</strong></li><li><strong>处理用户定制类型时应尽可能使用前置式，效率更高；</strong></li></ul><h2 id="9-构造与析构函数中的异常处理"><a href="#9-构造与析构函数中的异常处理" class="headerlink" title="9.构造与析构函数中的异常处理"></a>9.构造与析构函数中的异常处理</h2><p>构造函数可以抛出异常，析构函数不能抛出异常；</p><h4 id="a-在construtctors内阻止资源泄露（resource-leak）"><a href="#a-在construtctors内阻止资源泄露（resource-leak）" class="headerlink" title="a.在construtctors内阻止资源泄露（resource leak）"></a>a.在construtctors内阻止资源泄露（resource leak）</h4><p>c++只会析构已经构造完成的对象，对象只有在其constructor执行完毕才算是完全构造妥当。所以如果类对象构造函数执行期间可能产生<strong>exception（</strong>例如调用new无法分配足够的内存<strong>）</strong>，那么该构造函数就必须负责捕捉<strong>exception</strong>，并在继续传播它们之前先执行任何必要的清理工作;有两种方法解决此问题：</p><ul><li>将释放类成员内存的代码抽出放进一个private辅助函数中,然后构造与析构函数都调用它;</li><li>以智能指针unique_ptr(11)对象来取代pointer class members;(推荐)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法一</span><br>calss A &#123;<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-type">char</span>* m_image;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">A</span>()&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        m_image = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1024</span>];<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (...) &#123;<br>            <span class="hljs-built_in">cleanup</span>();<br>            <span class="hljs-keyword">throw</span>;<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()&#123;<br>        <span class="hljs-built_in">cleanup</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_image != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_image;<br>            m_image = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//方法二</span><br>calss A &#123;<br><span class="hljs-keyword">private</span>: <br>    unique_ptr&lt;<span class="hljs-type">char</span>*&gt; m_image;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">A</span>()&#123;<br>        m_image = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1024</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="b-别让异常逃离析构函数"><a href="#b-别让异常逃离析构函数" class="headerlink" title="b.别让异常逃离析构函数"></a>b.别让异常逃离析构函数</h4><p>析构函数有两个地方可能被调用。一是对象在正常状态下被销毁，这时抛出异常完全没问题；二是前面有异常抛出，正在清理堆栈，调用析构函数，这时如果再抛出异常，两个异常同时存在，异常处理机制只能terminate()；例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Widget</span>()&#123;...&#125;    <span class="hljs-comment">//假设这个可能吐出一个异常</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dosomething</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Widget&gt; v;<br>&#125;                    <span class="hljs-comment">//v在这里被自动销毁</span><br></code></pre></td></tr></table></figure><p>当vector v被销毁，它有责任销毁其内涵的所有Widget，假设v内含十个Widget，而在析构第一个元素期间，有个异常被抛出。其它九个Widget还是应该被销毁（否则它们保存的任何资源都会发生泄漏），因此，v应该调用它们各个析构函数。但假设在那些调用期间，第二个Widget析构函数又抛出异常，现在有两个同时作用的异常，这对C++而言太多了。<strong>在两个异常同时存在的情况下，程序若不是结束执行就是导致不明确行为</strong>。<br>正确处理析构函数异常推荐方法：</p><ul><li>记录信息吞下异常(不传播);<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//责数据库连接类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConnection</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">static</span> DBConnection <span class="hljs-title">create</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这个函数返回DBConnection对象</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//关闭联机，失败则抛出异常</span><br>&#125;;<br><span class="hljs-comment">//为确保客户不忘记在DBConnection对象身上调用close()</span><br><span class="hljs-comment">//一个合理的想法是创建一个用来管理DBConnection资源的class，并在其析构函数中调用close</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBMgr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 确保数据库连接总是会被关闭</span><br>    ~<span class="hljs-built_in">DBMgr</span>()&#123;<br>        db.<span class="hljs-built_in">close</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    DBConnection db;<br>&#125;;<br><br>DBMgr::~<span class="hljs-built_in">DBMgr</span>()&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        db.<span class="hljs-built_in">close</span>();<br>    &#125;<span class="hljs-built_in">catch</span>(...)&#123;<br>        ... <span class="hljs-comment">//制作运转记录，记下对close的调用失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="10-以by-refernce-方式捕捉exceptions"><a href="#10-以by-refernce-方式捕捉exceptions" class="headerlink" title="10.以by refernce 方式捕捉exceptions"></a>10.以by refernce 方式捕捉exceptions</h2><p>一个对象被抛出作为exception时，无论何种形式总是会发生复制。当以值方式捕捉异常时，会额外增加一次临时对象复制，此外还会出现继承体系的切割问题（抛出子类对象异常在捕捉时以父类对象捕捉，该对象调用虚函数为父类实现而非子类l）；当以指针方式捕捉异常时，必须有办法让exception object在控制权离开那个“抛出指针”的函数后依然存在（Global对象及static对象都没有问题），否则catch子句所收到的指针将指向不复存在的对象；以引用方式捕捉异常则不会出现上述问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">exception</span> &#123; <span class="hljs-comment">//c++标准exception class</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回此exception的一份简要描述</span><br>    ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">runtime_error</span>:<span class="hljs-keyword">public</span> exception &#123;<br>    ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Validation_error</span>:<span class="hljs-keyword">public</span> runtime_error &#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Validation_error</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//错误</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">someFunction</span>();<br>    &#125; <span class="hljs-built_in">catch</span>(exception ex)&#123;<br>    std::cerr&lt;&lt; ex.<span class="hljs-built_in">what</span>(); <span class="hljs-comment">//调用的是exception::what()</span><br>        ...<br>        <span class="hljs-keyword">throw</span> ex; <span class="hljs-comment">//效率低(抛出一个副本)，多拷贝一次类型且总是exception</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//正确</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">someFunction</span>();<br>    &#125; <span class="hljs-built_in">catch</span>(exception&amp; ex)&#123;<br>    std::cerr&lt;&lt; ex.<span class="hljs-built_in">what</span>(); <span class="hljs-comment">//调用的是Validation_error::what()</span><br>        ...<br>        <span class="hljs-keyword">throw</span>; <span class="hljs-comment">//效率高(不需要产生新的exception object)且重新抛出当前exception(没有改变exception的类型)</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>Effective</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xml/json/yaml区别详解(转)</title>
    <link href="/2022/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2022-06-25-xml-json-yaml/"/>
    <url>/2022/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2022-06-25-xml-json-yaml/</url>
    
    <content type="html"><![CDATA[<h2 id="信息标记"><a href="#信息标记" class="headerlink" title="信息标记"></a>信息标记</h2><p>       实际应用中的原始数据往往是杂乱无章的，为了更加方便组织和存储各种信息，以及为计算机处理、传播消息提供一种统一的方法。必须对信息进行一定的标记，信息标记的特点一般有以下几点：<br>       1、标记后的信息可形成信息组织结构，增加了信息维度<br>       2、标记的结构与信息一样具有重要价值<br>       3、标记后的信息可用于通信、存储或展示<br>       4、标记后的信息更利于程序理解和运用<br>       常用的信息标记主要有XML、JSON、YAML三种，基于WWW(World Wide Web)的信息组织方式是HTML(HyperText Markup Language，超文本标记语言)。</p><h2 id="XML-可扩展标记语言"><a href="#XML-可扩展标记语言" class="headerlink" title="XML(可扩展标记语言)"></a>XML(可扩展标记语言)</h2><h3 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h3><p>       XML（Extensible Markup Language）即可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。<br>       在电子计算机中，标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种的信息比如文章等。它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。是Internet环境中跨平台的、依赖于内容的技术，也是当今处理分布式结构信息的有效工具。<br>       1998年2月，W3C正式批准了可扩展标记语言的标准定义，可扩展标记语言可以对文档和数据进行结构化处理，从而能够在部门、客户和供应商之间进行交换，实现动态内容生成，企业集成和应用开发。可扩展标记语言可以使我们能够更准确的搜索，更方便的传送软件组件，更好的描述一些事物。例如电子商务交易等。<br>       XML和HTML都是标准通用标记语言的子集，XML是被设计用来传输和存储数据，而HTML是被设计用来显示数据的。<br>       XML语言具有如下一些特点：<br>       1、可扩展标记语言是一种很像超文本标记语言的标记语言。<br>       2、它的设计宗旨是传输数据，而不是显示数据。<br>       3、它的标签没有被预定义。需要自行定义标签。<br>       4、它被设计为具有自我描述性。<br>       5、它是W3C的推荐标准。</p><h3 id="XML与HTML的区别"><a href="#XML与HTML的区别" class="headerlink" title="XML与HTML的区别"></a>XML与HTML的区别</h3><p>       1、XML不是HTML的替代。而是对HTML的补充。<br>       2、它和HTML为不同的目的而设计：XML被设计用来传输和存储数据，其焦点是数据的内容。HTML被设计用来显示数据，其焦点是数据的外观。<br>       3、HTML旨在显示信息，而XML旨在传输信息。对XML最好的描述是：它是独立于软件和硬件的信息传输工具。</p><h3 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h3><p>       XML去掉了之前令许多开发人员头疼的标准通用标记语言的随意语法。在XML中，采用了如下的语法：<br>       1、任何的起始标签都必须有一个结束标签。<br>       2、可以采用另一种简化语法，可以在一个标签中同时表示起始和结束标签。这种语法是在大于符号之前紧跟一个斜线（&#x2F;），例如&lt;简化语法&#x2F;&gt;。XML解析器会将其翻译成&lt;简化语法&gt;&lt;&#x2F;简化语法&gt;。<br>       3、标签必须按合适的顺序进行嵌套，所以结束标签必须按镜像顺序匹配起始标签。这好比是将起始和结束标签看作是数学中的左右括号：在没有关闭所有的内部括号之前，是不能关闭外面的括号的。<br>       4、所有的特性都必须有值。<br>       5、所有的特性都必须在值的周围加上双引号。<br>       这些规则使得开发一个XML解析器要简便得多，而且也除去了解析标准通用标记语言中花在判断何时何地应用那些奇怪语法规则上的工作。仅仅在XML出现后的前六年就衍生出多种不同的语言，包括MathML、SVG、RDF、RSS、SOAP、XSLT、XSL-FO，而同时也将HTML改进为XHTML。XML运用广泛，它的相关技术比较丰富，例如DTD、 XPath、XLink、XPoint、XSLT等；</p><h3 id="XML实例"><a href="#XML实例" class="headerlink" title="XML实例"></a>XML实例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">firstName</span>&gt;</span>Tian<span class="hljs-tag">&lt;/<span class="hljs-name">firstName</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">lastName</span>&gt;</span>Song<span class="hljs-tag">&lt;/<span class="hljs-name">lastName</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">streetAddr</span>&gt;</span>中关村南大街5号<span class="hljs-tag">&lt;/<span class="hljs-name">streetAddr</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">city</span>&gt;</span>北京市<span class="hljs-tag">&lt;/<span class="hljs-name">city</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">zipcode</span>&gt;</span>100081<span class="hljs-tag">&lt;/<span class="hljs-name">zipcode</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">prof</span>&gt;</span>Computer System<span class="hljs-tag">&lt;/<span class="hljs-name">prof</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">prof</span>&gt;</span>Security<span class="hljs-tag">&lt;/<span class="hljs-name">prof</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span><br><br>用XML表示中国部分省市数据如下：<br><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">country</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>中国<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">province</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>黑龙江<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">cities</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">city</span>&gt;</span>哈尔滨<span class="hljs-tag">&lt;/<span class="hljs-name">city</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">city</span>&gt;</span>大庆<span class="hljs-tag">&lt;/<span class="hljs-name">city</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">cities</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">province</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">province</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>广东<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">cities</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">city</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">city</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">city</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">city</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">city</span>&gt;</span>珠海<span class="hljs-tag">&lt;/<span class="hljs-name">city</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">cities</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">province</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">country</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JSON-JS对象标记"><a href="#JSON-JS对象标记" class="headerlink" title="JSON(JS对象标记)"></a>JSON(JS对象标记)</h2><p>       JSON(JavaScript ObjectNotation, JS 对象标记) 是一种轻量级的数据交换格式。它基于ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><h3 id="JSON-语法规则"><a href="#JSON-语法规则" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h3><p>       在 JS 语言中，一切都是对象。因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型：<br>       对象：对象在 JS 中是使用花括号包裹 {} 起来的内容，数据结构为 {key1：value1, key2：value2, …} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。<br>       数组：数组在 JS 中是方括号 [] 包裹起来的内容，数据结构为 [“java”, “javascript”,”vb”, …] 的索引结构。在 JS 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引使用得多。同样，值的类型可以是任意类型。<br>       1、对象表示为键值对<br>       2、数据由逗号分隔<br>       3、花括号保存对象<br>       4、方括号保存数组<br>       JSON键值对：是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同小异，键&#x2F;值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值;<br>       {“firstName”:”John”}，这很容易理解，等价于这条 JavaScript 语句：{firstName &#x3D; “John”}。<br>       JSON与JS 对象的关系：很多人搞不清楚 JSON 和 Js 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。如：<br>       var obj &#x3D; {a: ‘Hello’, b:’World’}; &#x2F;&#x2F; 这是一个 JS对象，注意键名也是可以使用引号包裹的。<br>       var json &#x3D; ‘{“a”:”Hello”, “b”: “World”}’; &#x2F;&#x2F; 这是一个 JSON 字符串，本质是一个字符串，键名必须用引号包裹。<br>       JSON和JS 对象互转：要实现从对象转换为 JSON 字符串，使用 JSON.stringify()方法：<br>       var json &#x3D; JSON.stringify({a: ‘Hello’,b: ‘World’}); &#x2F;&#x2F; 结果是 ‘{“a”: “Hello”,”b”: “World”}’<br>       要实现从 JSON 转换为对象，使用 JSON.parse() 方法：<br>       var obj &#x3D; JSON.parse(‘{“a”:”Hello”, “b”: “World”}’); &#x2F;&#x2F; 结果是 {a: ‘Hello’, b: ‘World’}</p><h3 id="JSON和XML的比较"><a href="#JSON和XML的比较" class="headerlink" title="JSON和XML的比较"></a>JSON和XML的比较</h3><p>       1、可读性。JSON和XML的可读性可谓不相上下，一边是简易的语法，一边是规范的标签形式，很难分出胜负。<br>       2、可扩展性。XML天生有很好的扩展性，JSON当然也有，没有什么是XML可以扩展而JSON却不能扩展的。不过JSON在Javascript主场作战，可以存储Javascript复合对象，有着xml不可比拟的优势。<br>       3、编码难度。XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有提供的工具。无工具的情况下，相信熟练的开发人员一样能很快的写出想要的xml文档和JSON字符串，不过，xml文档要多很多结构上的字符。<br>       4、解码难度。XML的解析方式有两种：一是通过文档模型解析，也就是通过父标签索引出一组标记。例如：xmlData.getElementsByTagName(“tagName”)，但是这样是要在预先知道文档结构的情况下使用，无法进行通用的封装。<br>       另外一种方法是遍历节点（document 以及 childNodes）。这个可以通过递归来实现，不过解析出来的数据仍旧是形式各异，往往也不能满足预先的要求。凡是这样可扩展的结构数据解析起来一定都很困难。<br>       JSON也同样如此。如果预先知道JSON结构的情况下，使用JSON进行数据传递简直是太美妙了，可以写出很实用美观可读性强的代码。如果你是纯粹的前台开发人员，一定会非常喜欢JSON。但是如果你是一个应用开发人员，就不是那么喜欢了，毕竟xml才是真正的结构化标记语言，用于进行数据传递。<br>       而如果不知道JSON的结构而去解析JSON的话，那简直是噩梦。费时费力不说，代码也会变得冗余拖沓，得到的结果也不尽人意。但是这样也不影响众多前台开发人员选择JSON。因为json.js中的toJSONString()就可以看到JSON的字符串结构。当然不是使用这个字符串，这样仍旧是噩梦。常用JSON的人看到这个字符串之后，就对JSON的结构很明了了，就更容易的操作JSON。<br>       以上是在Javascript中仅对于数据传递的xml与JSON的解析。在Javascript地盘内，JSON毕竟是主场作战，其优势当然要远远优越于xml。如果JSON中存储Javascript复合对象，而且不知道其结构的话，我相信很多程序员也一样是哭着解析JSON的。<br>       5、除了上述之外，JSON和XML还有另外一个很大的区别在于有效数据率。JSON作为数据包格式传输的时候具有更高的效率，这是因为JSON不像XML那样需要有严格的闭合标签，这就让有效数据量与总数据包比大大提升，从而减少同等数据流量的情况下，网络的传输压力。</p><h3 id="JSON实例"><a href="#JSON实例" class="headerlink" title="JSON实例"></a>JSON实例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>       “firstName” <span class="hljs-punctuation">:</span>“Tian” <span class="hljs-punctuation">,</span><br>       “lastName” <span class="hljs-punctuation">:</span>“Song” <span class="hljs-punctuation">,</span><br>       “address” <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                               “streetAddr” <span class="hljs-punctuation">:</span>“中关村南大街<span class="hljs-number">5</span>号” <span class="hljs-punctuation">,</span><br>                               “city” <span class="hljs-punctuation">:</span> “北京市” <span class="hljs-punctuation">,</span><br>                               “zipcode” <span class="hljs-punctuation">:</span> “<span class="hljs-number">100081</span>”<br>                       <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">,</span><br>       “prof”  <span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span> “Computer System” <span class="hljs-punctuation">,</span> “Security” <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><br>用JSON表示中国部分省市数据如下：<br><br><span class="hljs-punctuation">&#123;</span><br>       <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;中国&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;province&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>                               <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑龙江&quot;</span><span class="hljs-punctuation">,</span><br>                               <span class="hljs-attr">&quot;cities&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;哈尔滨&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;大庆&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">&#125;</span><br>                          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                       <span class="hljs-punctuation">&#123;</span><br>                                 <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;广东&quot;</span><span class="hljs-punctuation">,</span><br>                               <span class="hljs-attr">&quot;cities&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;广州&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;深圳&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;珠海&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">&#125;</span><br>       <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="YAML-另一种标记语言"><a href="#YAML-另一种标记语言" class="headerlink" title="YAML(另一种标记语言)"></a>YAML(另一种标记语言)</h2><h3 id="YAML简介"><a href="#YAML简介" class="headerlink" title="YAML简介"></a>YAML简介</h3><p>       YAML(YAML Ain’t Markup Language，另一种标记语言)，但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。<br>       它是类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。<br>YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表，标量等资料形态。它使用空白符号缩排和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种设定档、倾印除错内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。<br>       尽管它比较适合用来表达阶层式（hierarchical model）的数据结构，不过也有精致的语法可以表示关联性（relational model）的资料。<br>       由于YAML使用空白字符和分行来分隔资料，使的他特别适合用grep、Python、Perl、Ruby操作。<br>其让人最容易上手的特色是巧妙避开各种封闭符号，如：引号、各种括号等，这些符号在嵌套结构中会变得复杂而难以辨认。</p><h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3><p>       多行缩进：数据结构可以用类似大纲的缩排方式呈现，结构通过缩进来表示，连续的项目通过减号“-”来表示，map结构里面的key&#x2F;value对用冒号“:”来分隔。样例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">house:</span><br>       <span class="hljs-attr">family:</span><br>               <span class="hljs-attr">name:</span> <span class="hljs-string">Doe</span><br>               <span class="hljs-attr">parents:</span><br>                       <span class="hljs-bullet">-</span> <span class="hljs-string">John</span><br>                       <span class="hljs-bullet">-</span> <span class="hljs-string">Jane</span><br>               <span class="hljs-attr">children:</span><br>                       <span class="hljs-bullet">-</span> <span class="hljs-string">Paul</span><br>                       <span class="hljs-bullet">-</span> <span class="hljs-string">Mark</span><br>                       <span class="hljs-bullet">-</span> <span class="hljs-string">Simone</span><br>               <span class="hljs-attr">address:</span><br>                       <span class="hljs-string">number:34</span><br>                       <span class="hljs-string">street:Main</span> <span class="hljs-string">Street</span><br>                       <span class="hljs-string">city:Nowheretown</span><br>                       <span class="hljs-string">zipcode:12345</span><br></code></pre></td></tr></table></figure><p>       注意：1、字串不一定要用双引号标识；<br>       2、在缩排中空白字符的数目并不是非常重要，只要相同阶层的元素左侧对齐就可以了（不过不能使用TAB字符）；<br>       3、允许在文件中加入选择性的空行，以增加可读性；<br>       4、在一个档案中，可同时包含多个文件，并用“——”分隔；<br>       5、选择性的符号“…”可以用来表示档案结尾（在利用串流的通讯中，这非常有用，可以在不关闭串流的情况下，发送结束讯号）。<br>       单行缩写：YAML也有用来描述好几行相同结构的数据的缩写语法，数组用’[]’包括起来，hash用’{}’来包括。因此，上面的这个YAML能够缩写成这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">house:</span><br>       <span class="hljs-attr">family:</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">Doe</span>, <span class="hljs-attr">parents:</span> [<span class="hljs-string">John</span>, <span class="hljs-string">Jane</span>], <span class="hljs-attr">children:</span> [<span class="hljs-string">Paul</span>,<span class="hljs-string">Mark</span>, <span class="hljs-string">Simone</span>] &#125;<br>       <span class="hljs-attr">address:</span> &#123; <span class="hljs-attr">number:</span> <span class="hljs-number">34</span>, <span class="hljs-attr">street:</span> <span class="hljs-string">Main</span> <span class="hljs-string">Street</span>, <span class="hljs-attr">city:</span> <span class="hljs-string">Nowheretown</span>,<span class="hljs-attr">zipcode:</span> <span class="hljs-number">12345</span> &#125;<br></code></pre></td></tr></table></figure><p>       <strong>此外YAML使用| 表达整块数据 # 表示注释。</strong></p><h3 id="YAML与JSON的区别"><a href="#YAML与JSON的区别" class="headerlink" title="YAML与JSON的区别"></a>YAML与JSON的区别</h3><p>       虽然YAML是参考JSON，XML和SDL等语言，不过跟这些语言比起来，YAML仍有自己的特色。<br>       JSON的语法是YAML1.2版的子集，同时非常接近YAML1.0与1.1版的子集，因此大部分的JSON文件都可以被YAML的剖析器剖析。这是因为JSON的语法结构和YAML的内置格式相同。虽然大范围的分层也可以使用类似JSON的内置格式，不过YAML标准并不建议这样使用，除非这样编写能让文件可读性增加。YAML的许多扩展在JSON是找不到的，如：进阶资料形态、关系锚点、字串不需要双引号、映射资料形态会储存键值的顺序。</p><h3 id="YAML实例"><a href="#YAML实例" class="headerlink" title="YAML实例"></a>YAML实例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">firstName :</span> <span class="hljs-string">Tian</span><br><span class="hljs-attr">lastName :</span> <span class="hljs-string">Song</span><br><span class="hljs-attr">address  :</span><br>       <span class="hljs-attr">streetAddr :</span> <span class="hljs-string">中关村南大街5号</span><br>       <span class="hljs-attr">city  :</span> <span class="hljs-string">北京市</span><br>       <span class="hljs-attr">zipcode :</span> <span class="hljs-number">100081</span><br><span class="hljs-attr">prof  :</span><br><span class="hljs-string">‐Computer</span> <span class="hljs-string">System</span><br><span class="hljs-string">‐Security</span><br><br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>1、XML：最早的通用信息标记语言，可扩展性好，但繁琐，适用于Internet上的信息交互与传递；</strong><br><strong>2、JSON：信息<strong><strong>有类型</strong></strong>，适合程序处理(js)，较XML简洁，适用于移动应用云端和节点的信息通信，无注释。</strong><br><strong>3、YAML：信息<strong><strong>无类型</strong></strong>，文本信息比例最高，可读性好，适用于各类系统的配置文件，有注释易读。</strong></p><h3 id="信息提取的一般方法"><a href="#信息提取的一般方法" class="headerlink" title="信息提取的一般方法"></a>信息提取的一般方法</h3><p>       从标记后的信息(XML JSON YAML)中提取所关注的内容:(标记, 信息)。<br>       方法一：完整解析信息的标记形式，再提取关键信息，需要标记解析器。例如：bs4库的标签树遍历。<br>       优点：信息解析准确<br>       缺点：提取过程繁琐，速度慢<br>       方法二：无视标记形式，直接搜索关键信息。对信息的文本查找函数即可。<br>       优点：提取过程简洁，速度较快<br>       缺点：提取结果准确性与信息内容相关<br>       融合方法：结合形式解析与搜索方法，提取关键信息。需要标记解析器及文本查找函数。<br>———————  </p><p>原文：<a href="https://blog.csdn.net/zengxiantao1994/article/details/78267107">地址 </a></p>]]></content>
    
    
    
    <tags>
      
      <tag>xml</tag>
      
      <tag>json</tag>
      
      <tag>yaml</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小试牛刀</title>
    <link href="/2022/06/10/%E5%85%B6%E4%BB%96-2022-06-10-test/"/>
    <url>/2022/06/10/%E5%85%B6%E4%BB%96-2022-06-10-test/</url>
    
    <content type="html"><![CDATA[<p><strong>第一篇还没想好写啥😁，就先测试测试markdown语法吧，练练手先~</strong></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>代码测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将单词或短语表示为代码,例如：<code>&quot;Hello, world!&quot;</code></p><p>图片测试：</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/15/d75c9737d64afc21.jpg"></p><p>引用测试：</p><blockquote><p>这是一条引用</p></blockquote><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>无序列表测试：</p><ul><li>哈哈</li><li>帆帆</li><li>吼吼</li><li>威威</li></ul><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>链接测试：</p><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a></p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>分割线测试：</p><hr><p>1</p><hr><p>2</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
